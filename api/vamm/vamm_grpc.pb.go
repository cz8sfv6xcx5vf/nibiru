// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package vammv1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// VirtualAMMClient is the client API for VirtualAMM service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type VirtualAMMClient interface {
	// SwapInput TODO(godismercilex): comment how swap input differentiates from swap output
	SwapInput(ctx context.Context, in *SwapInputRequest, opts ...grpc.CallOption) (*SwapInputResponse, error)
	// SwapOutput TODO(godismercilex): comment how swap output differentiates from swap input
	SwapOutput(ctx context.Context, in *SwapOutputRequest, opts ...grpc.CallOption) (*SwapOutputResponse, error)
	// Shutdown shutdowns the amm.
	Shutdown(ctx context.Context, in *ShutdownRequest, opts ...grpc.CallOption) (*ShutdownResponse, error)
	// SettleFunding settles the funding.
	SettleFunding(ctx context.Context, in *SettleFundingRequest, opts ...grpc.CallOption) (*SettleFundingResponse, error)
	CalcFee(ctx context.Context, in *CalcFeeRequest, opts ...grpc.CallOption) (*CalcFeeResponse, error)
	IsOverFluctuationLimit(ctx context.Context, in *IsOverFluctuationLimitRequest, opts ...grpc.CallOption) (*IsOverFluctuationLimitResponse, error)
	CalcBaseAssetAfterLiquidityMigration(ctx context.Context, in *CalcBaseAssetAfterLiquidityMigrationRequest, opts ...grpc.CallOption) (*CalcBaseAssetAfterLiquidityMigrationResponse, error)
	GetInputTWAP(ctx context.Context, in *GetInputTWAPRequest, opts ...grpc.CallOption) (*GetInputTWAPResponse, error)
	GetOutputTWAP(ctx context.Context, in *GetOutputTWAPRequest, opts ...grpc.CallOption) (*GetOutputTWAPResponse, error)
	GetInputPrice(ctx context.Context, in *GetInputPriceRequest, opts ...grpc.CallOption) (*GetInputPriceResponse, error)
	GetOutputPrice(ctx context.Context, in *GetOutputPriceRequest, opts ...grpc.CallOption) (*GetOutputPriceResponse, error)
	GetInputPriceWithReserves(ctx context.Context, in *GetInputPriceWithReservesRequest, opts ...grpc.CallOption) (*GetInputPriceWithReservesResponse, error)
	GetOutputPriceWithReserves(ctx context.Context, in *GetOutputPriceWithReservesRequest, opts ...grpc.CallOption) (*GetOutputPriceWithReservesResponse, error)
	GetSpotPrice(ctx context.Context, in *GetSpotPriceRequest, opts ...grpc.CallOption) (*GetSpotPriceResponse, error)
	GetLiquidityHistoryLength(ctx context.Context, in *GetLiquidityHistoryLengthRequest, opts ...grpc.CallOption) (*GetLiquidityHistoryLengthResponse, error)
	QuoteAsset(ctx context.Context, in *QuoteAssetRequest, opts ...grpc.CallOption) (*QuoteAssetResponse, error)
	Open(ctx context.Context, in *OpenRequest, opts ...grpc.CallOption) (*OpenResponse, error)
	GetSettlementPrice(ctx context.Context, in *GetSettlementPriceRequest, opts ...grpc.CallOption) (*GetSettlementPriceResponse, error)
	GetBaseAssetDeltaThisFundingPeriod(ctx context.Context, in *GetBaseAssetDeltaThisFundingPeriodRequest, opts ...grpc.CallOption) (*GetBaseAssetDeltaThisFundingPeriodResponse, error)
	GetCumulativeNotional(ctx context.Context, in *GetCumulativeNotionalRequest, opts ...grpc.CallOption) (*GetCumulativeNotionalResponse, error)
	GetMaxHoldingBaseAsset(ctx context.Context, in *GetMaxHoldingBaseAssetRequest, opts ...grpc.CallOption) (*GetMaxHoldingBaseAssetResponse, error)
	GetOpenInterestNotionalCap(ctx context.Context, in *GetOpenInterestNotionalCapRequest, opts ...grpc.CallOption) (*GetOpenInterestNotionalCapResponse, error)
	GetLiquidityChangedSnapshots(ctx context.Context, in *GetLiquidityChangedSnapshotsRequest, opts ...grpc.CallOption) (*GetLiquidityChangedSnapshotsResponse, error)
	GetBaseAssetDelta(ctx context.Context, in *GetBaseAssetDeltaRequest, opts ...grpc.CallOption) (*GetBaseAssetDeltaResponse, error)
	GetUnderlyingPrice(ctx context.Context, in *GetUnderlyingPriceRequest, opts ...grpc.CallOption) (*GetUnderlyingPriceResponse, error)
	IsOverSpreadLimit(ctx context.Context, in *IsOverSpreadLimitRequest, opts ...grpc.CallOption) (*IsOverSpreadLimitResponse, error)
}

type virtualAMMClient struct {
	cc grpc.ClientConnInterface
}

func NewVirtualAMMClient(cc grpc.ClientConnInterface) VirtualAMMClient {
	return &virtualAMMClient{cc}
}

func (c *virtualAMMClient) SwapInput(ctx context.Context, in *SwapInputRequest, opts ...grpc.CallOption) (*SwapInputResponse, error) {
	out := new(SwapInputResponse)
	err := c.cc.Invoke(ctx, "/matrix.vamm.v1.VirtualAMM/SwapInput", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualAMMClient) SwapOutput(ctx context.Context, in *SwapOutputRequest, opts ...grpc.CallOption) (*SwapOutputResponse, error) {
	out := new(SwapOutputResponse)
	err := c.cc.Invoke(ctx, "/matrix.vamm.v1.VirtualAMM/SwapOutput", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualAMMClient) Shutdown(ctx context.Context, in *ShutdownRequest, opts ...grpc.CallOption) (*ShutdownResponse, error) {
	out := new(ShutdownResponse)
	err := c.cc.Invoke(ctx, "/matrix.vamm.v1.VirtualAMM/Shutdown", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualAMMClient) SettleFunding(ctx context.Context, in *SettleFundingRequest, opts ...grpc.CallOption) (*SettleFundingResponse, error) {
	out := new(SettleFundingResponse)
	err := c.cc.Invoke(ctx, "/matrix.vamm.v1.VirtualAMM/SettleFunding", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualAMMClient) CalcFee(ctx context.Context, in *CalcFeeRequest, opts ...grpc.CallOption) (*CalcFeeResponse, error) {
	out := new(CalcFeeResponse)
	err := c.cc.Invoke(ctx, "/matrix.vamm.v1.VirtualAMM/CalcFee", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualAMMClient) IsOverFluctuationLimit(ctx context.Context, in *IsOverFluctuationLimitRequest, opts ...grpc.CallOption) (*IsOverFluctuationLimitResponse, error) {
	out := new(IsOverFluctuationLimitResponse)
	err := c.cc.Invoke(ctx, "/matrix.vamm.v1.VirtualAMM/IsOverFluctuationLimit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualAMMClient) CalcBaseAssetAfterLiquidityMigration(ctx context.Context, in *CalcBaseAssetAfterLiquidityMigrationRequest, opts ...grpc.CallOption) (*CalcBaseAssetAfterLiquidityMigrationResponse, error) {
	out := new(CalcBaseAssetAfterLiquidityMigrationResponse)
	err := c.cc.Invoke(ctx, "/matrix.vamm.v1.VirtualAMM/CalcBaseAssetAfterLiquidityMigration", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualAMMClient) GetInputTWAP(ctx context.Context, in *GetInputTWAPRequest, opts ...grpc.CallOption) (*GetInputTWAPResponse, error) {
	out := new(GetInputTWAPResponse)
	err := c.cc.Invoke(ctx, "/matrix.vamm.v1.VirtualAMM/GetInputTWAP", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualAMMClient) GetOutputTWAP(ctx context.Context, in *GetOutputTWAPRequest, opts ...grpc.CallOption) (*GetOutputTWAPResponse, error) {
	out := new(GetOutputTWAPResponse)
	err := c.cc.Invoke(ctx, "/matrix.vamm.v1.VirtualAMM/GetOutputTWAP", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualAMMClient) GetInputPrice(ctx context.Context, in *GetInputPriceRequest, opts ...grpc.CallOption) (*GetInputPriceResponse, error) {
	out := new(GetInputPriceResponse)
	err := c.cc.Invoke(ctx, "/matrix.vamm.v1.VirtualAMM/GetInputPrice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualAMMClient) GetOutputPrice(ctx context.Context, in *GetOutputPriceRequest, opts ...grpc.CallOption) (*GetOutputPriceResponse, error) {
	out := new(GetOutputPriceResponse)
	err := c.cc.Invoke(ctx, "/matrix.vamm.v1.VirtualAMM/GetOutputPrice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualAMMClient) GetInputPriceWithReserves(ctx context.Context, in *GetInputPriceWithReservesRequest, opts ...grpc.CallOption) (*GetInputPriceWithReservesResponse, error) {
	out := new(GetInputPriceWithReservesResponse)
	err := c.cc.Invoke(ctx, "/matrix.vamm.v1.VirtualAMM/GetInputPriceWithReserves", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualAMMClient) GetOutputPriceWithReserves(ctx context.Context, in *GetOutputPriceWithReservesRequest, opts ...grpc.CallOption) (*GetOutputPriceWithReservesResponse, error) {
	out := new(GetOutputPriceWithReservesResponse)
	err := c.cc.Invoke(ctx, "/matrix.vamm.v1.VirtualAMM/GetOutputPriceWithReserves", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualAMMClient) GetSpotPrice(ctx context.Context, in *GetSpotPriceRequest, opts ...grpc.CallOption) (*GetSpotPriceResponse, error) {
	out := new(GetSpotPriceResponse)
	err := c.cc.Invoke(ctx, "/matrix.vamm.v1.VirtualAMM/GetSpotPrice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualAMMClient) GetLiquidityHistoryLength(ctx context.Context, in *GetLiquidityHistoryLengthRequest, opts ...grpc.CallOption) (*GetLiquidityHistoryLengthResponse, error) {
	out := new(GetLiquidityHistoryLengthResponse)
	err := c.cc.Invoke(ctx, "/matrix.vamm.v1.VirtualAMM/GetLiquidityHistoryLength", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualAMMClient) QuoteAsset(ctx context.Context, in *QuoteAssetRequest, opts ...grpc.CallOption) (*QuoteAssetResponse, error) {
	out := new(QuoteAssetResponse)
	err := c.cc.Invoke(ctx, "/matrix.vamm.v1.VirtualAMM/QuoteAsset", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualAMMClient) Open(ctx context.Context, in *OpenRequest, opts ...grpc.CallOption) (*OpenResponse, error) {
	out := new(OpenResponse)
	err := c.cc.Invoke(ctx, "/matrix.vamm.v1.VirtualAMM/Open", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualAMMClient) GetSettlementPrice(ctx context.Context, in *GetSettlementPriceRequest, opts ...grpc.CallOption) (*GetSettlementPriceResponse, error) {
	out := new(GetSettlementPriceResponse)
	err := c.cc.Invoke(ctx, "/matrix.vamm.v1.VirtualAMM/GetSettlementPrice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualAMMClient) GetBaseAssetDeltaThisFundingPeriod(ctx context.Context, in *GetBaseAssetDeltaThisFundingPeriodRequest, opts ...grpc.CallOption) (*GetBaseAssetDeltaThisFundingPeriodResponse, error) {
	out := new(GetBaseAssetDeltaThisFundingPeriodResponse)
	err := c.cc.Invoke(ctx, "/matrix.vamm.v1.VirtualAMM/GetBaseAssetDeltaThisFundingPeriod", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualAMMClient) GetCumulativeNotional(ctx context.Context, in *GetCumulativeNotionalRequest, opts ...grpc.CallOption) (*GetCumulativeNotionalResponse, error) {
	out := new(GetCumulativeNotionalResponse)
	err := c.cc.Invoke(ctx, "/matrix.vamm.v1.VirtualAMM/GetCumulativeNotional", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualAMMClient) GetMaxHoldingBaseAsset(ctx context.Context, in *GetMaxHoldingBaseAssetRequest, opts ...grpc.CallOption) (*GetMaxHoldingBaseAssetResponse, error) {
	out := new(GetMaxHoldingBaseAssetResponse)
	err := c.cc.Invoke(ctx, "/matrix.vamm.v1.VirtualAMM/GetMaxHoldingBaseAsset", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualAMMClient) GetOpenInterestNotionalCap(ctx context.Context, in *GetOpenInterestNotionalCapRequest, opts ...grpc.CallOption) (*GetOpenInterestNotionalCapResponse, error) {
	out := new(GetOpenInterestNotionalCapResponse)
	err := c.cc.Invoke(ctx, "/matrix.vamm.v1.VirtualAMM/GetOpenInterestNotionalCap", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualAMMClient) GetLiquidityChangedSnapshots(ctx context.Context, in *GetLiquidityChangedSnapshotsRequest, opts ...grpc.CallOption) (*GetLiquidityChangedSnapshotsResponse, error) {
	out := new(GetLiquidityChangedSnapshotsResponse)
	err := c.cc.Invoke(ctx, "/matrix.vamm.v1.VirtualAMM/GetLiquidityChangedSnapshots", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualAMMClient) GetBaseAssetDelta(ctx context.Context, in *GetBaseAssetDeltaRequest, opts ...grpc.CallOption) (*GetBaseAssetDeltaResponse, error) {
	out := new(GetBaseAssetDeltaResponse)
	err := c.cc.Invoke(ctx, "/matrix.vamm.v1.VirtualAMM/GetBaseAssetDelta", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualAMMClient) GetUnderlyingPrice(ctx context.Context, in *GetUnderlyingPriceRequest, opts ...grpc.CallOption) (*GetUnderlyingPriceResponse, error) {
	out := new(GetUnderlyingPriceResponse)
	err := c.cc.Invoke(ctx, "/matrix.vamm.v1.VirtualAMM/GetUnderlyingPrice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualAMMClient) IsOverSpreadLimit(ctx context.Context, in *IsOverSpreadLimitRequest, opts ...grpc.CallOption) (*IsOverSpreadLimitResponse, error) {
	out := new(IsOverSpreadLimitResponse)
	err := c.cc.Invoke(ctx, "/matrix.vamm.v1.VirtualAMM/IsOverSpreadLimit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VirtualAMMServer is the server API for VirtualAMM service.
// All implementations must embed UnimplementedVirtualAMMServer
// for forward compatibility
type VirtualAMMServer interface {
	// SwapInput TODO(godismercilex): comment how swap input differentiates from swap output
	SwapInput(context.Context, *SwapInputRequest) (*SwapInputResponse, error)
	// SwapOutput TODO(godismercilex): comment how swap output differentiates from swap input
	SwapOutput(context.Context, *SwapOutputRequest) (*SwapOutputResponse, error)
	// Shutdown shutdowns the amm.
	Shutdown(context.Context, *ShutdownRequest) (*ShutdownResponse, error)
	// SettleFunding settles the funding.
	SettleFunding(context.Context, *SettleFundingRequest) (*SettleFundingResponse, error)
	CalcFee(context.Context, *CalcFeeRequest) (*CalcFeeResponse, error)
	IsOverFluctuationLimit(context.Context, *IsOverFluctuationLimitRequest) (*IsOverFluctuationLimitResponse, error)
	CalcBaseAssetAfterLiquidityMigration(context.Context, *CalcBaseAssetAfterLiquidityMigrationRequest) (*CalcBaseAssetAfterLiquidityMigrationResponse, error)
	GetInputTWAP(context.Context, *GetInputTWAPRequest) (*GetInputTWAPResponse, error)
	GetOutputTWAP(context.Context, *GetOutputTWAPRequest) (*GetOutputTWAPResponse, error)
	GetInputPrice(context.Context, *GetInputPriceRequest) (*GetInputPriceResponse, error)
	GetOutputPrice(context.Context, *GetOutputPriceRequest) (*GetOutputPriceResponse, error)
	GetInputPriceWithReserves(context.Context, *GetInputPriceWithReservesRequest) (*GetInputPriceWithReservesResponse, error)
	GetOutputPriceWithReserves(context.Context, *GetOutputPriceWithReservesRequest) (*GetOutputPriceWithReservesResponse, error)
	GetSpotPrice(context.Context, *GetSpotPriceRequest) (*GetSpotPriceResponse, error)
	GetLiquidityHistoryLength(context.Context, *GetLiquidityHistoryLengthRequest) (*GetLiquidityHistoryLengthResponse, error)
	QuoteAsset(context.Context, *QuoteAssetRequest) (*QuoteAssetResponse, error)
	Open(context.Context, *OpenRequest) (*OpenResponse, error)
	GetSettlementPrice(context.Context, *GetSettlementPriceRequest) (*GetSettlementPriceResponse, error)
	GetBaseAssetDeltaThisFundingPeriod(context.Context, *GetBaseAssetDeltaThisFundingPeriodRequest) (*GetBaseAssetDeltaThisFundingPeriodResponse, error)
	GetCumulativeNotional(context.Context, *GetCumulativeNotionalRequest) (*GetCumulativeNotionalResponse, error)
	GetMaxHoldingBaseAsset(context.Context, *GetMaxHoldingBaseAssetRequest) (*GetMaxHoldingBaseAssetResponse, error)
	GetOpenInterestNotionalCap(context.Context, *GetOpenInterestNotionalCapRequest) (*GetOpenInterestNotionalCapResponse, error)
	GetLiquidityChangedSnapshots(context.Context, *GetLiquidityChangedSnapshotsRequest) (*GetLiquidityChangedSnapshotsResponse, error)
	GetBaseAssetDelta(context.Context, *GetBaseAssetDeltaRequest) (*GetBaseAssetDeltaResponse, error)
	GetUnderlyingPrice(context.Context, *GetUnderlyingPriceRequest) (*GetUnderlyingPriceResponse, error)
	IsOverSpreadLimit(context.Context, *IsOverSpreadLimitRequest) (*IsOverSpreadLimitResponse, error)
	mustEmbedUnimplementedVirtualAMMServer()
}

// UnimplementedVirtualAMMServer must be embedded to have forward compatible implementations.
type UnimplementedVirtualAMMServer struct {
}

func (UnimplementedVirtualAMMServer) SwapInput(context.Context, *SwapInputRequest) (*SwapInputResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SwapInput not implemented")
}
func (UnimplementedVirtualAMMServer) SwapOutput(context.Context, *SwapOutputRequest) (*SwapOutputResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SwapOutput not implemented")
}
func (UnimplementedVirtualAMMServer) Shutdown(context.Context, *ShutdownRequest) (*ShutdownResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Shutdown not implemented")
}
func (UnimplementedVirtualAMMServer) SettleFunding(context.Context, *SettleFundingRequest) (*SettleFundingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SettleFunding not implemented")
}
func (UnimplementedVirtualAMMServer) CalcFee(context.Context, *CalcFeeRequest) (*CalcFeeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CalcFee not implemented")
}
func (UnimplementedVirtualAMMServer) IsOverFluctuationLimit(context.Context, *IsOverFluctuationLimitRequest) (*IsOverFluctuationLimitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsOverFluctuationLimit not implemented")
}
func (UnimplementedVirtualAMMServer) CalcBaseAssetAfterLiquidityMigration(context.Context, *CalcBaseAssetAfterLiquidityMigrationRequest) (*CalcBaseAssetAfterLiquidityMigrationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CalcBaseAssetAfterLiquidityMigration not implemented")
}
func (UnimplementedVirtualAMMServer) GetInputTWAP(context.Context, *GetInputTWAPRequest) (*GetInputTWAPResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInputTWAP not implemented")
}
func (UnimplementedVirtualAMMServer) GetOutputTWAP(context.Context, *GetOutputTWAPRequest) (*GetOutputTWAPResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOutputTWAP not implemented")
}
func (UnimplementedVirtualAMMServer) GetInputPrice(context.Context, *GetInputPriceRequest) (*GetInputPriceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInputPrice not implemented")
}
func (UnimplementedVirtualAMMServer) GetOutputPrice(context.Context, *GetOutputPriceRequest) (*GetOutputPriceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOutputPrice not implemented")
}
func (UnimplementedVirtualAMMServer) GetInputPriceWithReserves(context.Context, *GetInputPriceWithReservesRequest) (*GetInputPriceWithReservesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInputPriceWithReserves not implemented")
}
func (UnimplementedVirtualAMMServer) GetOutputPriceWithReserves(context.Context, *GetOutputPriceWithReservesRequest) (*GetOutputPriceWithReservesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOutputPriceWithReserves not implemented")
}
func (UnimplementedVirtualAMMServer) GetSpotPrice(context.Context, *GetSpotPriceRequest) (*GetSpotPriceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSpotPrice not implemented")
}
func (UnimplementedVirtualAMMServer) GetLiquidityHistoryLength(context.Context, *GetLiquidityHistoryLengthRequest) (*GetLiquidityHistoryLengthResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLiquidityHistoryLength not implemented")
}
func (UnimplementedVirtualAMMServer) QuoteAsset(context.Context, *QuoteAssetRequest) (*QuoteAssetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QuoteAsset not implemented")
}
func (UnimplementedVirtualAMMServer) Open(context.Context, *OpenRequest) (*OpenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Open not implemented")
}
func (UnimplementedVirtualAMMServer) GetSettlementPrice(context.Context, *GetSettlementPriceRequest) (*GetSettlementPriceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSettlementPrice not implemented")
}
func (UnimplementedVirtualAMMServer) GetBaseAssetDeltaThisFundingPeriod(context.Context, *GetBaseAssetDeltaThisFundingPeriodRequest) (*GetBaseAssetDeltaThisFundingPeriodResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBaseAssetDeltaThisFundingPeriod not implemented")
}
func (UnimplementedVirtualAMMServer) GetCumulativeNotional(context.Context, *GetCumulativeNotionalRequest) (*GetCumulativeNotionalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCumulativeNotional not implemented")
}
func (UnimplementedVirtualAMMServer) GetMaxHoldingBaseAsset(context.Context, *GetMaxHoldingBaseAssetRequest) (*GetMaxHoldingBaseAssetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMaxHoldingBaseAsset not implemented")
}
func (UnimplementedVirtualAMMServer) GetOpenInterestNotionalCap(context.Context, *GetOpenInterestNotionalCapRequest) (*GetOpenInterestNotionalCapResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOpenInterestNotionalCap not implemented")
}
func (UnimplementedVirtualAMMServer) GetLiquidityChangedSnapshots(context.Context, *GetLiquidityChangedSnapshotsRequest) (*GetLiquidityChangedSnapshotsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLiquidityChangedSnapshots not implemented")
}
func (UnimplementedVirtualAMMServer) GetBaseAssetDelta(context.Context, *GetBaseAssetDeltaRequest) (*GetBaseAssetDeltaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBaseAssetDelta not implemented")
}
func (UnimplementedVirtualAMMServer) GetUnderlyingPrice(context.Context, *GetUnderlyingPriceRequest) (*GetUnderlyingPriceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUnderlyingPrice not implemented")
}
func (UnimplementedVirtualAMMServer) IsOverSpreadLimit(context.Context, *IsOverSpreadLimitRequest) (*IsOverSpreadLimitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsOverSpreadLimit not implemented")
}
func (UnimplementedVirtualAMMServer) mustEmbedUnimplementedVirtualAMMServer() {}

// UnsafeVirtualAMMServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VirtualAMMServer will
// result in compilation errors.
type UnsafeVirtualAMMServer interface {
	mustEmbedUnimplementedVirtualAMMServer()
}

func RegisterVirtualAMMServer(s grpc.ServiceRegistrar, srv VirtualAMMServer) {
	s.RegisterService(&VirtualAMM_ServiceDesc, srv)
}

func _VirtualAMM_SwapInput_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SwapInputRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualAMMServer).SwapInput(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/matrix.vamm.v1.VirtualAMM/SwapInput",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualAMMServer).SwapInput(ctx, req.(*SwapInputRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualAMM_SwapOutput_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SwapOutputRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualAMMServer).SwapOutput(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/matrix.vamm.v1.VirtualAMM/SwapOutput",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualAMMServer).SwapOutput(ctx, req.(*SwapOutputRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualAMM_Shutdown_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShutdownRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualAMMServer).Shutdown(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/matrix.vamm.v1.VirtualAMM/Shutdown",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualAMMServer).Shutdown(ctx, req.(*ShutdownRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualAMM_SettleFunding_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SettleFundingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualAMMServer).SettleFunding(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/matrix.vamm.v1.VirtualAMM/SettleFunding",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualAMMServer).SettleFunding(ctx, req.(*SettleFundingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualAMM_CalcFee_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CalcFeeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualAMMServer).CalcFee(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/matrix.vamm.v1.VirtualAMM/CalcFee",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualAMMServer).CalcFee(ctx, req.(*CalcFeeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualAMM_IsOverFluctuationLimit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsOverFluctuationLimitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualAMMServer).IsOverFluctuationLimit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/matrix.vamm.v1.VirtualAMM/IsOverFluctuationLimit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualAMMServer).IsOverFluctuationLimit(ctx, req.(*IsOverFluctuationLimitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualAMM_CalcBaseAssetAfterLiquidityMigration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CalcBaseAssetAfterLiquidityMigrationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualAMMServer).CalcBaseAssetAfterLiquidityMigration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/matrix.vamm.v1.VirtualAMM/CalcBaseAssetAfterLiquidityMigration",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualAMMServer).CalcBaseAssetAfterLiquidityMigration(ctx, req.(*CalcBaseAssetAfterLiquidityMigrationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualAMM_GetInputTWAP_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInputTWAPRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualAMMServer).GetInputTWAP(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/matrix.vamm.v1.VirtualAMM/GetInputTWAP",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualAMMServer).GetInputTWAP(ctx, req.(*GetInputTWAPRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualAMM_GetOutputTWAP_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOutputTWAPRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualAMMServer).GetOutputTWAP(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/matrix.vamm.v1.VirtualAMM/GetOutputTWAP",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualAMMServer).GetOutputTWAP(ctx, req.(*GetOutputTWAPRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualAMM_GetInputPrice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInputPriceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualAMMServer).GetInputPrice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/matrix.vamm.v1.VirtualAMM/GetInputPrice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualAMMServer).GetInputPrice(ctx, req.(*GetInputPriceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualAMM_GetOutputPrice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOutputPriceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualAMMServer).GetOutputPrice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/matrix.vamm.v1.VirtualAMM/GetOutputPrice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualAMMServer).GetOutputPrice(ctx, req.(*GetOutputPriceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualAMM_GetInputPriceWithReserves_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInputPriceWithReservesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualAMMServer).GetInputPriceWithReserves(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/matrix.vamm.v1.VirtualAMM/GetInputPriceWithReserves",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualAMMServer).GetInputPriceWithReserves(ctx, req.(*GetInputPriceWithReservesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualAMM_GetOutputPriceWithReserves_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOutputPriceWithReservesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualAMMServer).GetOutputPriceWithReserves(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/matrix.vamm.v1.VirtualAMM/GetOutputPriceWithReserves",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualAMMServer).GetOutputPriceWithReserves(ctx, req.(*GetOutputPriceWithReservesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualAMM_GetSpotPrice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSpotPriceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualAMMServer).GetSpotPrice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/matrix.vamm.v1.VirtualAMM/GetSpotPrice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualAMMServer).GetSpotPrice(ctx, req.(*GetSpotPriceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualAMM_GetLiquidityHistoryLength_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLiquidityHistoryLengthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualAMMServer).GetLiquidityHistoryLength(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/matrix.vamm.v1.VirtualAMM/GetLiquidityHistoryLength",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualAMMServer).GetLiquidityHistoryLength(ctx, req.(*GetLiquidityHistoryLengthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualAMM_QuoteAsset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuoteAssetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualAMMServer).QuoteAsset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/matrix.vamm.v1.VirtualAMM/QuoteAsset",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualAMMServer).QuoteAsset(ctx, req.(*QuoteAssetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualAMM_Open_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OpenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualAMMServer).Open(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/matrix.vamm.v1.VirtualAMM/Open",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualAMMServer).Open(ctx, req.(*OpenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualAMM_GetSettlementPrice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSettlementPriceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualAMMServer).GetSettlementPrice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/matrix.vamm.v1.VirtualAMM/GetSettlementPrice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualAMMServer).GetSettlementPrice(ctx, req.(*GetSettlementPriceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualAMM_GetBaseAssetDeltaThisFundingPeriod_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBaseAssetDeltaThisFundingPeriodRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualAMMServer).GetBaseAssetDeltaThisFundingPeriod(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/matrix.vamm.v1.VirtualAMM/GetBaseAssetDeltaThisFundingPeriod",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualAMMServer).GetBaseAssetDeltaThisFundingPeriod(ctx, req.(*GetBaseAssetDeltaThisFundingPeriodRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualAMM_GetCumulativeNotional_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCumulativeNotionalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualAMMServer).GetCumulativeNotional(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/matrix.vamm.v1.VirtualAMM/GetCumulativeNotional",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualAMMServer).GetCumulativeNotional(ctx, req.(*GetCumulativeNotionalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualAMM_GetMaxHoldingBaseAsset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMaxHoldingBaseAssetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualAMMServer).GetMaxHoldingBaseAsset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/matrix.vamm.v1.VirtualAMM/GetMaxHoldingBaseAsset",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualAMMServer).GetMaxHoldingBaseAsset(ctx, req.(*GetMaxHoldingBaseAssetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualAMM_GetOpenInterestNotionalCap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOpenInterestNotionalCapRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualAMMServer).GetOpenInterestNotionalCap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/matrix.vamm.v1.VirtualAMM/GetOpenInterestNotionalCap",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualAMMServer).GetOpenInterestNotionalCap(ctx, req.(*GetOpenInterestNotionalCapRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualAMM_GetLiquidityChangedSnapshots_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLiquidityChangedSnapshotsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualAMMServer).GetLiquidityChangedSnapshots(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/matrix.vamm.v1.VirtualAMM/GetLiquidityChangedSnapshots",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualAMMServer).GetLiquidityChangedSnapshots(ctx, req.(*GetLiquidityChangedSnapshotsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualAMM_GetBaseAssetDelta_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBaseAssetDeltaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualAMMServer).GetBaseAssetDelta(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/matrix.vamm.v1.VirtualAMM/GetBaseAssetDelta",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualAMMServer).GetBaseAssetDelta(ctx, req.(*GetBaseAssetDeltaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualAMM_GetUnderlyingPrice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUnderlyingPriceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualAMMServer).GetUnderlyingPrice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/matrix.vamm.v1.VirtualAMM/GetUnderlyingPrice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualAMMServer).GetUnderlyingPrice(ctx, req.(*GetUnderlyingPriceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualAMM_IsOverSpreadLimit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsOverSpreadLimitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualAMMServer).IsOverSpreadLimit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/matrix.vamm.v1.VirtualAMM/IsOverSpreadLimit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualAMMServer).IsOverSpreadLimit(ctx, req.(*IsOverSpreadLimitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// VirtualAMM_ServiceDesc is the grpc.ServiceDesc for VirtualAMM service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var VirtualAMM_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "matrix.vamm.v1.VirtualAMM",
	HandlerType: (*VirtualAMMServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SwapInput",
			Handler:    _VirtualAMM_SwapInput_Handler,
		},
		{
			MethodName: "SwapOutput",
			Handler:    _VirtualAMM_SwapOutput_Handler,
		},
		{
			MethodName: "Shutdown",
			Handler:    _VirtualAMM_Shutdown_Handler,
		},
		{
			MethodName: "SettleFunding",
			Handler:    _VirtualAMM_SettleFunding_Handler,
		},
		{
			MethodName: "CalcFee",
			Handler:    _VirtualAMM_CalcFee_Handler,
		},
		{
			MethodName: "IsOverFluctuationLimit",
			Handler:    _VirtualAMM_IsOverFluctuationLimit_Handler,
		},
		{
			MethodName: "CalcBaseAssetAfterLiquidityMigration",
			Handler:    _VirtualAMM_CalcBaseAssetAfterLiquidityMigration_Handler,
		},
		{
			MethodName: "GetInputTWAP",
			Handler:    _VirtualAMM_GetInputTWAP_Handler,
		},
		{
			MethodName: "GetOutputTWAP",
			Handler:    _VirtualAMM_GetOutputTWAP_Handler,
		},
		{
			MethodName: "GetInputPrice",
			Handler:    _VirtualAMM_GetInputPrice_Handler,
		},
		{
			MethodName: "GetOutputPrice",
			Handler:    _VirtualAMM_GetOutputPrice_Handler,
		},
		{
			MethodName: "GetInputPriceWithReserves",
			Handler:    _VirtualAMM_GetInputPriceWithReserves_Handler,
		},
		{
			MethodName: "GetOutputPriceWithReserves",
			Handler:    _VirtualAMM_GetOutputPriceWithReserves_Handler,
		},
		{
			MethodName: "GetSpotPrice",
			Handler:    _VirtualAMM_GetSpotPrice_Handler,
		},
		{
			MethodName: "GetLiquidityHistoryLength",
			Handler:    _VirtualAMM_GetLiquidityHistoryLength_Handler,
		},
		{
			MethodName: "QuoteAsset",
			Handler:    _VirtualAMM_QuoteAsset_Handler,
		},
		{
			MethodName: "Open",
			Handler:    _VirtualAMM_Open_Handler,
		},
		{
			MethodName: "GetSettlementPrice",
			Handler:    _VirtualAMM_GetSettlementPrice_Handler,
		},
		{
			MethodName: "GetBaseAssetDeltaThisFundingPeriod",
			Handler:    _VirtualAMM_GetBaseAssetDeltaThisFundingPeriod_Handler,
		},
		{
			MethodName: "GetCumulativeNotional",
			Handler:    _VirtualAMM_GetCumulativeNotional_Handler,
		},
		{
			MethodName: "GetMaxHoldingBaseAsset",
			Handler:    _VirtualAMM_GetMaxHoldingBaseAsset_Handler,
		},
		{
			MethodName: "GetOpenInterestNotionalCap",
			Handler:    _VirtualAMM_GetOpenInterestNotionalCap_Handler,
		},
		{
			MethodName: "GetLiquidityChangedSnapshots",
			Handler:    _VirtualAMM_GetLiquidityChangedSnapshots_Handler,
		},
		{
			MethodName: "GetBaseAssetDelta",
			Handler:    _VirtualAMM_GetBaseAssetDelta_Handler,
		},
		{
			MethodName: "GetUnderlyingPrice",
			Handler:    _VirtualAMM_GetUnderlyingPrice_Handler,
		},
		{
			MethodName: "IsOverSpreadLimit",
			Handler:    _VirtualAMM_IsOverSpreadLimit_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vamm/vamm.proto",
}
