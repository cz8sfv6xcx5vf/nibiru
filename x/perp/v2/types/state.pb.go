// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: nibiru/perp/v2/state.proto

package types

import (
	fmt "fmt"
	github_com_NibiruChain_nibiru_x_common_asset "github.com/NibiruChain/nibiru/x/common/asset"
	_ "github.com/cosmos/cosmos-proto"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	_ "google.golang.org/protobuf/types/known/durationpb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// The direction that the user is trading in
// LONG means the user is going long the base asset (e.g. buy BTC)
// SHORT means the user is shorting the base asset (e.g. sell BTC)
type Direction int32

const (
	Direction_DIRECTION_UNSPECIFIED Direction = 0
	Direction_LONG                  Direction = 1
	Direction_SHORT                 Direction = 2
)

var Direction_name = map[int32]string{
	0: "DIRECTION_UNSPECIFIED",
	1: "LONG",
	2: "SHORT",
}

var Direction_value = map[string]int32{
	"DIRECTION_UNSPECIFIED": 0,
	"LONG":                  1,
	"SHORT":                 2,
}

func (x Direction) String() string {
	return proto.EnumName(Direction_name, int32(x))
}

func (Direction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8f4829f34f7b8040, []int{0}
}

// Enumerates different options of calculating twap.
type TwapCalcOption int32

const (
	TwapCalcOption_TWAP_CALC_OPTION_UNSPECIFIED TwapCalcOption = 0
	// Spot price from quote asset reserve / base asset reserve
	TwapCalcOption_SPOT TwapCalcOption = 1
	// Swapping with quote assets, output denominated in base assets
	TwapCalcOption_QUOTE_ASSET_SWAP TwapCalcOption = 2
	// Swapping with base assets, output denominated in quote assets
	TwapCalcOption_BASE_ASSET_SWAP TwapCalcOption = 3
)

var TwapCalcOption_name = map[int32]string{
	0: "TWAP_CALC_OPTION_UNSPECIFIED",
	1: "SPOT",
	2: "QUOTE_ASSET_SWAP",
	3: "BASE_ASSET_SWAP",
}

var TwapCalcOption_value = map[string]int32{
	"TWAP_CALC_OPTION_UNSPECIFIED": 0,
	"SPOT":                         1,
	"QUOTE_ASSET_SWAP":             2,
	"BASE_ASSET_SWAP":              3,
}

func (x TwapCalcOption) String() string {
	return proto.EnumName(TwapCalcOption_name, int32(x))
}

func (TwapCalcOption) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8f4829f34f7b8040, []int{1}
}

type Market struct {
	// the trading pair represented by this market
	// always BASE:QUOTE, e.g. BTC:NUSD or ETH:NUSD
	Pair github_com_NibiruChain_nibiru_x_common_asset.Pair `protobuf:"bytes,1,opt,name=pair,proto3,customtype=github.com/NibiruChain/nibiru/x/common/asset.Pair" json:"pair"`
	// whether or not the market is enabled
	Enabled bool `protobuf:"varint,2,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// the minimum margin ratio which a user must maintain on this market
	MaintenanceMarginRatio github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,3,opt,name=maintenance_margin_ratio,json=maintenanceMarginRatio,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"maintenance_margin_ratio"`
	// the maximum leverage a user is able to be taken on this market
	MaxLeverage github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,4,opt,name=max_leverage,json=maxLeverage,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"max_leverage"`
	// Latest cumulative premium fraction for a given pair.
	// Calculated once per funding rate interval.
	// A premium fraction is the difference between mark and index, divided by the
	// number of payments per day. (mark - index) / # payments in a day
	LatestCumulativePremiumFraction github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,5,opt,name=latest_cumulative_premium_fraction,json=latestCumulativePremiumFraction,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"latest_cumulative_premium_fraction"`
	// the percentage of the notional given to the exchange when trading
	ExchangeFeeRatio github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,6,opt,name=exchange_fee_ratio,json=exchangeFeeRatio,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"exchange_fee_ratio"`
	// the percentage of the notional transferred to the ecosystem fund when
	// trading
	EcosystemFundFeeRatio github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,7,opt,name=ecosystem_fund_fee_ratio,json=ecosystemFundFeeRatio,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"ecosystem_fund_fee_ratio"`
	// the percentage of liquidated position that will be
	// given to out as a reward. Half of the liquidation fee is given to the
	// liquidator, and the other half is given to the ecosystem fund.
	LiquidationFeeRatio github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,8,opt,name=liquidation_fee_ratio,json=liquidationFeeRatio,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"liquidation_fee_ratio"`
	// the portion of the position size we try to liquidate if the available
	// margin is higher than liquidation fee
	PartialLiquidationRatio github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,9,opt,name=partial_liquidation_ratio,json=partialLiquidationRatio,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"partial_liquidation_ratio"`
	// specifies the interval on which the funding rate is updated
	FundingRateEpochId string `protobuf:"bytes,10,opt,name=funding_rate_epoch_id,json=fundingRateEpochId,proto3" json:"funding_rate_epoch_id,omitempty"`
	// amount of time to look back for TWAP calculations
	TwapLookbackWindow time.Duration `protobuf:"bytes,11,opt,name=twap_lookback_window,json=twapLookbackWindow,proto3,stdduration" json:"twap_lookback_window"`
	// the amount of collateral already credited from the ecosystem fund
	PrepaidBadDebt types.Coin `protobuf:"bytes,12,opt,name=prepaid_bad_debt,json=prepaidBadDebt,proto3" json:"prepaid_bad_debt"`
	// the maximum funding rate payment per epoch, this represents the maximum
	// amount of funding that can be paid out per epoch as a percentage of the
	// position size
	MaxFundingRate github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,13,opt,name=max_funding_rate,json=maxFundingRate,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec,stdduration" json:"max_funding_rate"`
}

func (m *Market) Reset()         { *m = Market{} }
func (m *Market) String() string { return proto.CompactTextString(m) }
func (*Market) ProtoMessage()    {}
func (*Market) Descriptor() ([]byte, []int) {
	return fileDescriptor_8f4829f34f7b8040, []int{0}
}
func (m *Market) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Market) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Market.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Market) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Market.Merge(m, src)
}
func (m *Market) XXX_Size() int {
	return m.Size()
}
func (m *Market) XXX_DiscardUnknown() {
	xxx_messageInfo_Market.DiscardUnknown(m)
}

var xxx_messageInfo_Market proto.InternalMessageInfo

func (m *Market) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *Market) GetFundingRateEpochId() string {
	if m != nil {
		return m.FundingRateEpochId
	}
	return ""
}

func (m *Market) GetTwapLookbackWindow() time.Duration {
	if m != nil {
		return m.TwapLookbackWindow
	}
	return 0
}

func (m *Market) GetPrepaidBadDebt() types.Coin {
	if m != nil {
		return m.PrepaidBadDebt
	}
	return types.Coin{}
}

type AMM struct {
	// identifies the market this AMM belongs to
	Pair github_com_NibiruChain_nibiru_x_common_asset.Pair `protobuf:"bytes,1,opt,name=pair,proto3,customtype=github.com/NibiruChain/nibiru/x/common/asset.Pair" json:"pair"`
	// the amount of base reserves this AMM has
	BaseReserve github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,2,opt,name=base_reserve,json=baseReserve,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"base_reserve"`
	// the amount of quote reserves this AMM has
	QuoteReserve github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,3,opt,name=quote_reserve,json=quoteReserve,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"quote_reserve"`
	// sqrt(k)
	SqrtDepth github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,4,opt,name=sqrt_depth,json=sqrtDepth,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"sqrt_depth"`
	// the price multiplier of the dynamic AMM
	PriceMultiplier github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,5,opt,name=price_multiplier,json=priceMultiplier,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"price_multiplier"`
	// Total long refers to the sum of long open notional in base.
	TotalLong github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,6,opt,name=total_long,json=totalLong,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"total_long"`
	// Total short refers to the sum of short open notional in base.
	TotalShort github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,7,opt,name=total_short,json=totalShort,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"total_short"`
}

func (m *AMM) Reset()         { *m = AMM{} }
func (m *AMM) String() string { return proto.CompactTextString(m) }
func (*AMM) ProtoMessage()    {}
func (*AMM) Descriptor() ([]byte, []int) {
	return fileDescriptor_8f4829f34f7b8040, []int{1}
}
func (m *AMM) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AMM) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AMM.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AMM) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AMM.Merge(m, src)
}
func (m *AMM) XXX_Size() int {
	return m.Size()
}
func (m *AMM) XXX_DiscardUnknown() {
	xxx_messageInfo_AMM.DiscardUnknown(m)
}

var xxx_messageInfo_AMM proto.InternalMessageInfo

type Position struct {
	// address identifies the address owner of this position
	TraderAddress string `protobuf:"bytes,1,opt,name=trader_address,json=traderAddress,proto3" json:"trader_address,omitempty"`
	// pair identifies the pair associated with this position
	Pair github_com_NibiruChain_nibiru_x_common_asset.Pair `protobuf:"bytes,2,opt,name=pair,proto3,customtype=github.com/NibiruChain/nibiru/x/common/asset.Pair" json:"pair"`
	// the position size
	Size_ github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,3,opt,name=size,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"size"`
	// amount of margin remaining in the position
	Margin github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,4,opt,name=margin,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"margin"`
	// value of position in quote assets when opened
	OpenNotional github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,5,opt,name=open_notional,json=openNotional,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"open_notional"`
	// The most recent cumulative premium fraction this position has.
	// Used to calculate the next funding payment.
	LatestCumulativePremiumFraction github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,6,opt,name=latest_cumulative_premium_fraction,json=latestCumulativePremiumFraction,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"latest_cumulative_premium_fraction"`
	// last block number this position was updated
	LastUpdatedBlockNumber int64 `protobuf:"varint,7,opt,name=last_updated_block_number,json=lastUpdatedBlockNumber,proto3" json:"last_updated_block_number,omitempty"`
}

func (m *Position) Reset()         { *m = Position{} }
func (m *Position) String() string { return proto.CompactTextString(m) }
func (*Position) ProtoMessage()    {}
func (*Position) Descriptor() ([]byte, []int) {
	return fileDescriptor_8f4829f34f7b8040, []int{2}
}
func (m *Position) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Position) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Position.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Position) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Position.Merge(m, src)
}
func (m *Position) XXX_Size() int {
	return m.Size()
}
func (m *Position) XXX_DiscardUnknown() {
	xxx_messageInfo_Position.DiscardUnknown(m)
}

var xxx_messageInfo_Position proto.InternalMessageInfo

func (m *Position) GetTraderAddress() string {
	if m != nil {
		return m.TraderAddress
	}
	return ""
}

func (m *Position) GetLastUpdatedBlockNumber() int64 {
	if m != nil {
		return m.LastUpdatedBlockNumber
	}
	return 0
}

// a snapshot of the perp.amm's reserves at a given point in time
type ReserveSnapshot struct {
	Amm AMM `protobuf:"bytes,1,opt,name=amm,proto3" json:"amm"`
	// milliseconds since unix epoch
	TimestampMs int64 `protobuf:"varint,2,opt,name=timestamp_ms,json=timestampMs,proto3" json:"timestamp_ms,omitempty"`
}

func (m *ReserveSnapshot) Reset()         { *m = ReserveSnapshot{} }
func (m *ReserveSnapshot) String() string { return proto.CompactTextString(m) }
func (*ReserveSnapshot) ProtoMessage()    {}
func (*ReserveSnapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_8f4829f34f7b8040, []int{3}
}
func (m *ReserveSnapshot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReserveSnapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReserveSnapshot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReserveSnapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReserveSnapshot.Merge(m, src)
}
func (m *ReserveSnapshot) XXX_Size() int {
	return m.Size()
}
func (m *ReserveSnapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_ReserveSnapshot.DiscardUnknown(m)
}

var xxx_messageInfo_ReserveSnapshot proto.InternalMessageInfo

func (m *ReserveSnapshot) GetAmm() AMM {
	if m != nil {
		return m.Amm
	}
	return AMM{}
}

func (m *ReserveSnapshot) GetTimestampMs() int64 {
	if m != nil {
		return m.TimestampMs
	}
	return 0
}

func init() {
	proto.RegisterEnum("nibiru.perp.v2.Direction", Direction_name, Direction_value)
	proto.RegisterEnum("nibiru.perp.v2.TwapCalcOption", TwapCalcOption_name, TwapCalcOption_value)
	proto.RegisterType((*Market)(nil), "nibiru.perp.v2.Market")
	proto.RegisterType((*AMM)(nil), "nibiru.perp.v2.AMM")
	proto.RegisterType((*Position)(nil), "nibiru.perp.v2.Position")
	proto.RegisterType((*ReserveSnapshot)(nil), "nibiru.perp.v2.ReserveSnapshot")
}

func init() { proto.RegisterFile("nibiru/perp/v2/state.proto", fileDescriptor_8f4829f34f7b8040) }

var fileDescriptor_8f4829f34f7b8040 = []byte{
	// 1057 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x96, 0x5d, 0x6f, 0xdb, 0x36,
	0x17, 0xc7, 0xe3, 0xd8, 0x4d, 0x6d, 0xda, 0x4d, 0x0d, 0xb6, 0xe9, 0xa3, 0x04, 0x0f, 0x9c, 0x2c,
	0xc0, 0x86, 0xa0, 0x43, 0x25, 0x24, 0xbb, 0x2a, 0x76, 0xe5, 0xd7, 0xce, 0x80, 0xdf, 0x22, 0x3b,
	0x08, 0x36, 0x14, 0x20, 0x28, 0x89, 0x91, 0xb9, 0x48, 0xa2, 0x42, 0x52, 0x4e, 0xba, 0x7d, 0x89,
	0x5d, 0x6e, 0x5f, 0x68, 0xe8, 0x65, 0x2f, 0x87, 0x5d, 0x74, 0x43, 0xf2, 0x19, 0x76, 0x3f, 0x90,
	0x92, 0x1d, 0x17, 0x18, 0xb0, 0x4d, 0xe8, 0xae, 0x6c, 0xf1, 0xe8, 0xfc, 0xfe, 0xd4, 0xd1, 0x39,
	0x7f, 0x0a, 0xec, 0x45, 0xd4, 0xa1, 0x3c, 0xb1, 0x62, 0xc2, 0x63, 0x6b, 0x71, 0x62, 0x09, 0x89,
	0x25, 0x31, 0x63, 0xce, 0x24, 0x83, 0xdb, 0x69, 0xcc, 0x54, 0x31, 0x73, 0x71, 0xb2, 0xf7, 0xd4,
	0x67, 0x3e, 0xd3, 0x21, 0x4b, 0xfd, 0x4b, 0xef, 0xda, 0x6b, 0xb8, 0x4c, 0x84, 0x4c, 0x58, 0x0e,
	0x16, 0xc4, 0x5a, 0x1c, 0x3b, 0x44, 0xe2, 0x63, 0xcb, 0x65, 0x34, 0xca, 0xe2, 0xbb, 0x69, 0x1c,
	0xa5, 0x89, 0xe9, 0xc5, 0x32, 0xd5, 0x67, 0xcc, 0x0f, 0x88, 0xa5, 0xaf, 0x9c, 0xe4, 0xc2, 0xf2,
	0x12, 0x8e, 0x25, 0x65, 0x59, 0xea, 0xe1, 0x1f, 0x65, 0xb0, 0x35, 0xc4, 0xfc, 0x92, 0x48, 0x38,
	0x04, 0xa5, 0x18, 0x53, 0x6e, 0x14, 0x0e, 0x0a, 0x47, 0x95, 0xd6, 0xcb, 0xb7, 0xef, 0xf7, 0x37,
	0x7e, 0x7d, 0xbf, 0x7f, 0xec, 0x53, 0x39, 0x4f, 0x1c, 0xd3, 0x65, 0xa1, 0x35, 0xd2, 0x9b, 0x6d,
	0xcf, 0x31, 0x8d, 0xac, 0xec, 0xa1, 0x6e, 0x2c, 0x97, 0x85, 0x21, 0x8b, 0x2c, 0x2c, 0x04, 0x91,
	0xe6, 0x04, 0x53, 0x6e, 0x6b, 0x0c, 0x34, 0xc0, 0x43, 0x12, 0x61, 0x27, 0x20, 0x9e, 0xb1, 0x79,
	0x50, 0x38, 0x2a, 0xdb, 0xcb, 0x4b, 0x38, 0x07, 0x46, 0x88, 0x69, 0x24, 0x49, 0x84, 0x23, 0x97,
	0xa0, 0x10, 0x73, 0x9f, 0x46, 0x48, 0x6f, 0xcb, 0x28, 0x6a, 0x71, 0x33, 0x13, 0xff, 0x6c, 0x4d,
	0x3c, 0xab, 0x41, 0xfa, 0xf3, 0x42, 0x78, 0x97, 0x96, 0x7c, 0x13, 0x13, 0x61, 0x76, 0x88, 0x6b,
	0x3f, 0x5b, 0xe3, 0x0d, 0x35, 0xce, 0x56, 0x34, 0x78, 0x0a, 0x6a, 0x21, 0xbe, 0x41, 0x01, 0x59,
	0x10, 0x8e, 0x7d, 0x62, 0x94, 0x72, 0xd1, 0xab, 0x21, 0xbe, 0x19, 0x64, 0x08, 0xf8, 0x3d, 0x38,
	0x0c, 0xb0, 0x24, 0x42, 0x22, 0x37, 0x09, 0x93, 0x00, 0x4b, 0xba, 0x20, 0x28, 0xe6, 0x24, 0xa4,
	0x49, 0x88, 0x2e, 0x38, 0x76, 0x55, 0x71, 0x8d, 0x07, 0xb9, 0x84, 0xf6, 0x53, 0x72, 0x7b, 0x05,
	0x9e, 0xa4, 0xdc, 0x5e, 0x86, 0x85, 0xaf, 0x01, 0x24, 0x37, 0xee, 0x1c, 0x47, 0x3e, 0x41, 0x17,
	0x84, 0x64, 0x35, 0xdb, 0xca, 0x25, 0x56, 0x5f, 0x92, 0x7a, 0x84, 0xa4, 0xd5, 0xf2, 0x81, 0x41,
	0x5c, 0x26, 0xde, 0x08, 0x49, 0x42, 0x74, 0x91, 0x44, 0xde, 0x9a, 0xc6, 0xc3, 0x5c, 0x1a, 0x3b,
	0x2b, 0x5e, 0x2f, 0x89, 0xbc, 0x95, 0x90, 0x03, 0x76, 0x02, 0x7a, 0x95, 0x50, 0x4f, 0x77, 0xe2,
	0x9a, 0x4a, 0x39, 0x97, 0xca, 0x93, 0x35, 0xd8, 0x4a, 0xe3, 0x5b, 0xb0, 0x1b, 0x63, 0x2e, 0x29,
	0x0e, 0xd0, 0xba, 0x56, 0xaa, 0x53, 0xc9, 0xa5, 0xf3, 0xbf, 0x0c, 0x38, 0xb8, 0xe7, 0xa5, 0x5a,
	0xc7, 0x60, 0x47, 0x95, 0x8b, 0x46, 0xbe, 0xe2, 0x13, 0x44, 0x62, 0xe6, 0xce, 0x11, 0xf5, 0x0c,
	0xa0, 0x74, 0x6c, 0x98, 0x05, 0x6d, 0x2c, 0x49, 0x57, 0x85, 0xfa, 0x1e, 0x3c, 0x03, 0x4f, 0xe5,
	0x35, 0x8e, 0x51, 0xc0, 0xd8, 0xa5, 0x83, 0xdd, 0x4b, 0x74, 0x4d, 0x23, 0x8f, 0x5d, 0x1b, 0xd5,
	0x83, 0xc2, 0x51, 0xf5, 0x64, 0xd7, 0x4c, 0xc7, 0xd6, 0x5c, 0x8e, 0xad, 0xd9, 0xc9, 0xc6, 0xb6,
	0x55, 0x56, 0x9b, 0xfe, 0xf1, 0xb7, 0xfd, 0x82, 0x0d, 0x15, 0x60, 0x90, 0xe5, 0x9f, 0xeb, 0x74,
	0xd8, 0x07, 0xf5, 0x98, 0x93, 0x18, 0x53, 0x0f, 0x39, 0xd8, 0x43, 0x1e, 0x71, 0xa4, 0x51, 0xcb,
	0x90, 0x99, 0x2f, 0x28, 0x13, 0x31, 0x33, 0x13, 0x31, 0xdb, 0x8c, 0x46, 0xad, 0x92, 0x42, 0xda,
	0xdb, 0x59, 0x62, 0x0b, 0x7b, 0x1d, 0xe2, 0x48, 0xf8, 0x1a, 0xd4, 0xd5, 0xec, 0xac, 0x3f, 0x98,
	0xf1, 0x48, 0xd7, 0xed, 0xe4, 0xdf, 0xd5, 0x4d, 0x6f, 0x76, 0x3b, 0xc4, 0x37, 0xbd, 0xfb, 0x32,
	0x1c, 0xfe, 0x5c, 0x02, 0xc5, 0xe6, 0x70, 0xf8, 0xb1, 0x4d, 0xe7, 0x14, 0xd4, 0xd4, 0xf3, 0x21,
	0x4e, 0x04, 0xe1, 0x0b, 0xa2, 0x9d, 0x27, 0xc7, 0xc0, 0x2b, 0x86, 0x9d, 0x22, 0xe0, 0x14, 0x3c,
	0xba, 0x4a, 0x98, 0xbc, 0x67, 0xe6, 0xb3, 0xa8, 0x9a, 0x86, 0x2c, 0xa1, 0x43, 0x00, 0xc4, 0x15,
	0x97, 0xc8, 0x23, 0xb1, 0x9c, 0xe7, 0xb4, 0xa5, 0x8a, 0x22, 0x74, 0x14, 0x00, 0x7e, 0xad, 0x5e,
	0x3b, 0x55, 0x5e, 0x9a, 0x04, 0x92, 0xc6, 0x01, 0x25, 0x3c, 0xa7, 0x05, 0x3d, 0xd6, 0x9c, 0xe1,
	0x0a, 0xa3, 0x76, 0x2a, 0x99, 0x54, 0x53, 0xc4, 0x22, 0x3f, 0xa7, 0xd5, 0x54, 0x34, 0x61, 0xc0,
	0x22, 0x1f, 0x8e, 0x41, 0x35, 0xc5, 0x89, 0x39, 0xe3, 0x32, 0xa7, 0xad, 0xa4, 0x3b, 0x9a, 0x2a,
	0xc2, 0xe1, 0x4f, 0x25, 0x50, 0x9e, 0x30, 0x41, 0xb5, 0x3f, 0x7e, 0x0a, 0xb6, 0x25, 0xc7, 0x1e,
	0xe1, 0x08, 0x7b, 0x1e, 0x27, 0x42, 0xa4, 0x7d, 0x65, 0x3f, 0x4a, 0x57, 0x9b, 0xe9, 0xe2, 0xaa,
	0xe9, 0x36, 0x3f, 0x4e, 0xd3, 0xb5, 0x40, 0x49, 0xd0, 0xef, 0xf2, 0x36, 0x86, 0xce, 0x85, 0x3d,
	0xb0, 0x95, 0x9e, 0x83, 0x39, 0x9b, 0x21, 0xcb, 0x56, 0xdd, 0xca, 0x62, 0x12, 0xa1, 0x88, 0xa9,
	0x82, 0xe0, 0x20, 0x67, 0x1b, 0xd4, 0x14, 0x64, 0x94, 0x31, 0xfe, 0xe1, 0x99, 0xb7, 0xf5, 0xdf,
	0x9c, 0x79, 0x2f, 0xc1, 0x6e, 0x80, 0x85, 0x44, 0x49, 0xec, 0x61, 0x49, 0x3c, 0xe4, 0x04, 0xcc,
	0xbd, 0x44, 0x51, 0x12, 0x3a, 0x84, 0xeb, 0xfe, 0x29, 0xda, 0xcf, 0xd4, 0x0d, 0x67, 0x69, 0xbc,
	0xa5, 0xc2, 0x23, 0x1d, 0x3d, 0xc4, 0xe0, 0x71, 0x36, 0x70, 0xd3, 0x08, 0xc7, 0x62, 0xce, 0x24,
	0xfc, 0x1c, 0x14, 0x71, 0x18, 0xea, 0xb6, 0xa8, 0x9e, 0x3c, 0x31, 0x3f, 0xfc, 0xfc, 0x32, 0x9b,
	0xc3, 0x61, 0xe6, 0x86, 0xea, 0x2e, 0xf8, 0x09, 0xa8, 0x49, 0x1a, 0x12, 0x21, 0x71, 0x18, 0xa3,
	0x50, 0xe8, 0x7e, 0x29, 0xda, 0xd5, 0xd5, 0xda, 0x50, 0x3c, 0xff, 0x12, 0x54, 0x3a, 0x94, 0x93,
	0x74, 0xab, 0xbb, 0x60, 0xa7, 0xd3, 0xb7, 0xbb, 0xed, 0x59, 0x7f, 0x3c, 0x42, 0x67, 0xa3, 0xe9,
	0xa4, 0xdb, 0xee, 0xf7, 0xfa, 0xdd, 0x4e, 0x7d, 0x03, 0x96, 0x41, 0x69, 0x30, 0x1e, 0xbd, 0xaa,
	0x17, 0x60, 0x05, 0x3c, 0x98, 0x7e, 0x35, 0xb6, 0x67, 0xf5, 0xcd, 0xe7, 0x3e, 0xd8, 0x9e, 0x5d,
	0xe3, 0xb8, 0x8d, 0x03, 0x77, 0x1c, 0x6b, 0xc2, 0x01, 0xf8, 0xff, 0xec, 0xbc, 0x39, 0x41, 0xed,
	0xe6, 0xa0, 0x8d, 0xc6, 0x93, 0xbf, 0x06, 0x4d, 0x27, 0xe3, 0x59, 0xbd, 0x00, 0x9f, 0x82, 0xfa,
	0xe9, 0xd9, 0x78, 0xd6, 0x45, 0xcd, 0xe9, 0xb4, 0x3b, 0x43, 0xd3, 0xf3, 0xe6, 0xa4, 0xbe, 0x09,
	0x9f, 0x80, 0xc7, 0xad, 0xe6, 0xf4, 0x83, 0xc5, 0x62, 0xeb, 0xd5, 0xdb, 0xdb, 0x46, 0xe1, 0xdd,
	0x6d, 0xa3, 0xf0, 0xfb, 0x6d, 0xa3, 0xf0, 0xc3, 0x5d, 0x63, 0xe3, 0xdd, 0x5d, 0x63, 0xe3, 0x97,
	0xbb, 0xc6, 0xc6, 0x37, 0x2f, 0xfe, 0xae, 0xe9, 0x97, 0x5f, 0xad, 0xfa, 0x8d, 0x39, 0x5b, 0xfa,
	0x40, 0xfa, 0xe2, 0xcf, 0x00, 0x00, 0x00, 0xff, 0xff, 0xf3, 0x85, 0x1a, 0x6c, 0xd4, 0x0a, 0x00,
	0x00,
}

func (m *Market) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Market) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Market) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.MaxFundingRate.Size()
		i -= size
		if _, err := m.MaxFundingRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintState(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x6a
	{
		size, err := m.PrepaidBadDebt.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintState(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	n2, err2 := github_com_cosmos_gogoproto_types.StdDurationMarshalTo(m.TwapLookbackWindow, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdDuration(m.TwapLookbackWindow):])
	if err2 != nil {
		return 0, err2
	}
	i -= n2
	i = encodeVarintState(dAtA, i, uint64(n2))
	i--
	dAtA[i] = 0x5a
	if len(m.FundingRateEpochId) > 0 {
		i -= len(m.FundingRateEpochId)
		copy(dAtA[i:], m.FundingRateEpochId)
		i = encodeVarintState(dAtA, i, uint64(len(m.FundingRateEpochId)))
		i--
		dAtA[i] = 0x52
	}
	{
		size := m.PartialLiquidationRatio.Size()
		i -= size
		if _, err := m.PartialLiquidationRatio.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintState(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	{
		size := m.LiquidationFeeRatio.Size()
		i -= size
		if _, err := m.LiquidationFeeRatio.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintState(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size := m.EcosystemFundFeeRatio.Size()
		i -= size
		if _, err := m.EcosystemFundFeeRatio.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintState(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size := m.ExchangeFeeRatio.Size()
		i -= size
		if _, err := m.ExchangeFeeRatio.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintState(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.LatestCumulativePremiumFraction.Size()
		i -= size
		if _, err := m.LatestCumulativePremiumFraction.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintState(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.MaxLeverage.Size()
		i -= size
		if _, err := m.MaxLeverage.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintState(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.MaintenanceMarginRatio.Size()
		i -= size
		if _, err := m.MaintenanceMarginRatio.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintState(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	{
		size := m.Pair.Size()
		i -= size
		if _, err := m.Pair.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintState(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AMM) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AMM) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AMM) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.TotalShort.Size()
		i -= size
		if _, err := m.TotalShort.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintState(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size := m.TotalLong.Size()
		i -= size
		if _, err := m.TotalLong.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintState(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.PriceMultiplier.Size()
		i -= size
		if _, err := m.PriceMultiplier.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintState(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.SqrtDepth.Size()
		i -= size
		if _, err := m.SqrtDepth.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintState(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.QuoteReserve.Size()
		i -= size
		if _, err := m.QuoteReserve.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintState(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.BaseReserve.Size()
		i -= size
		if _, err := m.BaseReserve.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintState(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.Pair.Size()
		i -= size
		if _, err := m.Pair.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintState(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Position) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Position) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Position) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastUpdatedBlockNumber != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.LastUpdatedBlockNumber))
		i--
		dAtA[i] = 0x38
	}
	{
		size := m.LatestCumulativePremiumFraction.Size()
		i -= size
		if _, err := m.LatestCumulativePremiumFraction.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintState(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.OpenNotional.Size()
		i -= size
		if _, err := m.OpenNotional.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintState(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.Margin.Size()
		i -= size
		if _, err := m.Margin.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintState(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.Size_.Size()
		i -= size
		if _, err := m.Size_.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintState(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.Pair.Size()
		i -= size
		if _, err := m.Pair.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintState(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.TraderAddress) > 0 {
		i -= len(m.TraderAddress)
		copy(dAtA[i:], m.TraderAddress)
		i = encodeVarintState(dAtA, i, uint64(len(m.TraderAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReserveSnapshot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReserveSnapshot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReserveSnapshot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TimestampMs != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.TimestampMs))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.Amm.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintState(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintState(dAtA []byte, offset int, v uint64) int {
	offset -= sovState(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Market) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Pair.Size()
	n += 1 + l + sovState(uint64(l))
	if m.Enabled {
		n += 2
	}
	l = m.MaintenanceMarginRatio.Size()
	n += 1 + l + sovState(uint64(l))
	l = m.MaxLeverage.Size()
	n += 1 + l + sovState(uint64(l))
	l = m.LatestCumulativePremiumFraction.Size()
	n += 1 + l + sovState(uint64(l))
	l = m.ExchangeFeeRatio.Size()
	n += 1 + l + sovState(uint64(l))
	l = m.EcosystemFundFeeRatio.Size()
	n += 1 + l + sovState(uint64(l))
	l = m.LiquidationFeeRatio.Size()
	n += 1 + l + sovState(uint64(l))
	l = m.PartialLiquidationRatio.Size()
	n += 1 + l + sovState(uint64(l))
	l = len(m.FundingRateEpochId)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdDuration(m.TwapLookbackWindow)
	n += 1 + l + sovState(uint64(l))
	l = m.PrepaidBadDebt.Size()
	n += 1 + l + sovState(uint64(l))
	l = m.MaxFundingRate.Size()
	n += 1 + l + sovState(uint64(l))
	return n
}

func (m *AMM) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Pair.Size()
	n += 1 + l + sovState(uint64(l))
	l = m.BaseReserve.Size()
	n += 1 + l + sovState(uint64(l))
	l = m.QuoteReserve.Size()
	n += 1 + l + sovState(uint64(l))
	l = m.SqrtDepth.Size()
	n += 1 + l + sovState(uint64(l))
	l = m.PriceMultiplier.Size()
	n += 1 + l + sovState(uint64(l))
	l = m.TotalLong.Size()
	n += 1 + l + sovState(uint64(l))
	l = m.TotalShort.Size()
	n += 1 + l + sovState(uint64(l))
	return n
}

func (m *Position) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TraderAddress)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = m.Pair.Size()
	n += 1 + l + sovState(uint64(l))
	l = m.Size_.Size()
	n += 1 + l + sovState(uint64(l))
	l = m.Margin.Size()
	n += 1 + l + sovState(uint64(l))
	l = m.OpenNotional.Size()
	n += 1 + l + sovState(uint64(l))
	l = m.LatestCumulativePremiumFraction.Size()
	n += 1 + l + sovState(uint64(l))
	if m.LastUpdatedBlockNumber != 0 {
		n += 1 + sovState(uint64(m.LastUpdatedBlockNumber))
	}
	return n
}

func (m *ReserveSnapshot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Amm.Size()
	n += 1 + l + sovState(uint64(l))
	if m.TimestampMs != 0 {
		n += 1 + sovState(uint64(m.TimestampMs))
	}
	return n
}

func sovState(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozState(x uint64) (n int) {
	return sovState(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Market) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Market: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Market: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pair", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Pair.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaintenanceMarginRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaintenanceMarginRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxLeverage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxLeverage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestCumulativePremiumFraction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LatestCumulativePremiumFraction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExchangeFeeRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ExchangeFeeRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EcosystemFundFeeRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EcosystemFundFeeRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiquidationFeeRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LiquidationFeeRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartialLiquidationRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PartialLiquidationRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FundingRateEpochId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FundingRateEpochId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TwapLookbackWindow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdDurationUnmarshal(&m.TwapLookbackWindow, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrepaidBadDebt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PrepaidBadDebt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxFundingRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxFundingRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AMM) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AMM: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AMM: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pair", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Pair.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseReserve", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BaseReserve.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuoteReserve", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.QuoteReserve.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SqrtDepth", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SqrtDepth.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceMultiplier", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PriceMultiplier.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalLong", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalLong.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalShort", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalShort.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Position) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Position: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Position: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraderAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TraderAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pair", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Pair.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Size_.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Margin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Margin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenNotional", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OpenNotional.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestCumulativePremiumFraction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LatestCumulativePremiumFraction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdatedBlockNumber", wireType)
			}
			m.LastUpdatedBlockNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastUpdatedBlockNumber |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReserveSnapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReserveSnapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReserveSnapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amm", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amm.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampMs", wireType)
			}
			m.TimestampMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimestampMs |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipState(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowState
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowState
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowState
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthState
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupState
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthState
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthState        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowState          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupState = fmt.Errorf("proto: unexpected end of group")
)
