// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: nibiru/perp/v2/event.proto

package types

import (
	fmt "fmt"
	github_com_NibiruChain_nibiru_x_common_asset "github.com/NibiruChain/nibiru/x/common/asset"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type LiquidationFailedEvent_LiquidationFailedReason int32

const (
	LiquidationFailedEvent_UNSPECIFIED LiquidationFailedEvent_LiquidationFailedReason = 0
	// the position is healthy and does not need to be liquidated.
	LiquidationFailedEvent_POSITION_HEALTHY LiquidationFailedEvent_LiquidationFailedReason = 1
	// the pair does not exist.
	LiquidationFailedEvent_NONEXISTENT_PAIR LiquidationFailedEvent_LiquidationFailedReason = 2
	// the position does not exist.
	LiquidationFailedEvent_NONEXISTENT_POSITION LiquidationFailedEvent_LiquidationFailedReason = 3
)

var LiquidationFailedEvent_LiquidationFailedReason_name = map[int32]string{
	0: "UNSPECIFIED",
	1: "POSITION_HEALTHY",
	2: "NONEXISTENT_PAIR",
	3: "NONEXISTENT_POSITION",
}

var LiquidationFailedEvent_LiquidationFailedReason_value = map[string]int32{
	"UNSPECIFIED":          0,
	"POSITION_HEALTHY":     1,
	"NONEXISTENT_PAIR":     2,
	"NONEXISTENT_POSITION": 3,
}

func (x LiquidationFailedEvent_LiquidationFailedReason) String() string {
	return proto.EnumName(LiquidationFailedEvent_LiquidationFailedReason_name, int32(x))
}

func (LiquidationFailedEvent_LiquidationFailedReason) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a5313bbc89fa31dd, []int{4, 0}
}

// Emitted when a position changes.
type PositionChangedEvent struct {
	FinalPosition Position `protobuf:"bytes,1,opt,name=final_position,json=finalPosition,proto3" json:"final_position"`
	// Position notional (in quote units) after the change. In general,
	// 'notional = baseAmount * priceQuotePerBase', where size is the baseAmount.
	PositionNotional github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,2,opt,name=position_notional,json=positionNotional,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"position_notional"`
	// Transaction fee paid. A "taker" fee.
	TransactionFee types.Coin `protobuf:"bytes,3,opt,name=transaction_fee,json=transactionFee,proto3" json:"transaction_fee" yaml:"transaction_fee"`
	// realize profits and losses after the change
	RealizedPnl github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,4,opt,name=realized_pnl,json=realizedPnl,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"realized_pnl"`
	// Amount of bad debt cleared by the PerpEF during the change.
	// Bad debt is negative net margin past the liquidation point of a position.
	BadDebt types.Coin `protobuf:"bytes,5,opt,name=bad_debt,json=badDebt,proto3" json:"bad_debt"`
	// A funding payment made or received by the trader on the current position.
	//'fundingPayment' is positive if 'owner' is the sender and negative if 'owner'
	//is the receiver of the payment. Its magnitude is abs(size * fundingRate).
	//Funding payments act to converge the mark price and index price
	//(average price on major exchanges).
	FundingPayment github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,6,opt,name=funding_payment,json=fundingPayment,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"funding_payment"`
	// The block number at which this position was changed.
	BlockHeight int64 `protobuf:"varint,7,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
	// margin_to_user is the amount of collateral received by the trader during
	// the position change. A positve value indicates that the trader received
	// funds, while a negative value indicates that the trader spent funds.
	MarginToUser github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,8,opt,name=margin_to_user,json=marginToUser,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"margin_to_user"`
	// change_reason describes the reason for why the position resulted in a
	// change. Change type can take the following values:
	//
	// - CHANGE_REASON_UNSPECIFIED: Unspecified change reason.
	// - CHANGE_REASON_ADD_MARGIN: Margin was added to the position.
	// - CHANGE_REASON_REMOVE_MARGIN: Margin was removed from the position.
	// - CHANGE_REASON_OPEN_POSITION: A new position was opened.
	// - CHANGE_REASON_CLOSE_POSITION: An existing position was closed.
	ChangeReason ChangeReason `protobuf:"bytes,9,opt,name=change_reason,json=changeReason,proto3,customtype=ChangeReason" json:"change_reason"`
}

func (m *PositionChangedEvent) Reset()         { *m = PositionChangedEvent{} }
func (m *PositionChangedEvent) String() string { return proto.CompactTextString(m) }
func (*PositionChangedEvent) ProtoMessage()    {}
func (*PositionChangedEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_a5313bbc89fa31dd, []int{0}
}
func (m *PositionChangedEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PositionChangedEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PositionChangedEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PositionChangedEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PositionChangedEvent.Merge(m, src)
}
func (m *PositionChangedEvent) XXX_Size() int {
	return m.Size()
}
func (m *PositionChangedEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_PositionChangedEvent.DiscardUnknown(m)
}

var xxx_messageInfo_PositionChangedEvent proto.InternalMessageInfo

func (m *PositionChangedEvent) GetFinalPosition() Position {
	if m != nil {
		return m.FinalPosition
	}
	return Position{}
}

func (m *PositionChangedEvent) GetTransactionFee() types.Coin {
	if m != nil {
		return m.TransactionFee
	}
	return types.Coin{}
}

func (m *PositionChangedEvent) GetBadDebt() types.Coin {
	if m != nil {
		return m.BadDebt
	}
	return types.Coin{}
}

func (m *PositionChangedEvent) GetBlockHeight() int64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

// Emitted when a position is liquidated.
type PositionLiquidatedEvent struct {
	// identifier of the corresponding virtual pool for the position
	Pair github_com_NibiruChain_nibiru_x_common_asset.Pair `protobuf:"bytes,1,opt,name=pair,proto3,customtype=github.com/NibiruChain/nibiru/x/common/asset.Pair" json:"pair"`
	// owner of the position.
	TraderAddress string `protobuf:"bytes,2,opt,name=trader_address,json=traderAddress,proto3" json:"trader_address,omitempty"`
	// margin * leverage * vPrice. 'notional' is the virtual size times  the
	// virtual price on 'perp.amm'.
	ExchangedQuoteAmount github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,3,opt,name=exchanged_quote_amount,json=exchangedQuoteAmount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"exchanged_quote_amount"`
	// virtual amount of base assets for the position, which would be margin *
	// leverage * priceBasePerQuote.
	ExchangedPositionSize github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,4,opt,name=exchanged_position_size,json=exchangedPositionSize,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"exchanged_position_size"`
	// Address of the account that executed the tx.
	LiquidatorAddress string `protobuf:"bytes,5,opt,name=liquidator_address,json=liquidatorAddress,proto3" json:"liquidator_address,omitempty"`
	// Commission (in margin units) received by 'liquidator'.
	FeeToLiquidator types.Coin `protobuf:"bytes,6,opt,name=fee_to_liquidator,json=feeToLiquidator,proto3" json:"fee_to_liquidator" yaml:"fee_to_liquidator"`
	// Commission (in margin units) given to the ecosystem fund.
	FeeToEcosystemFund types.Coin `protobuf:"bytes,7,opt,name=fee_to_ecosystem_fund,json=feeToEcosystemFund,proto3" json:"fee_to_ecosystem_fund" yaml:"fee_to_ecosystem_fund"`
	//  Bad debt (margin units) cleared by the PerpEF during the tx. Bad debt is
	//  negative net margin past the liquidation point of a position.
	BadDebt types.Coin `protobuf:"bytes,8,opt,name=bad_debt,json=badDebt,proto3" json:"bad_debt"`
	// Remaining margin in the position after liquidation
	Margin types.Coin `protobuf:"bytes,9,opt,name=margin,proto3" json:"margin" yaml:"margin"`
	// Remaining position notional in the position after liquidation
	PositionNotional github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,10,opt,name=position_notional,json=positionNotional,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"position_notional"`
	// Remaining position size in the position after liquidation
	PositionSize github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,11,opt,name=position_size,json=positionSize,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"position_size"`
	// Unrealized PnL in the position after liquidation
	UnrealizedPnl github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,12,opt,name=unrealizedPnl,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"unrealizedPnl"`
	// Spot price of the vAMM after liquidation
	MarkPrice github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,13,opt,name=mark_price,json=markPrice,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"mark_price"`
	// The block number at which this liquidation occured.
	BlockHeight int64 `protobuf:"varint,14,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
	// The unix timestamp in milliseconds at which this liquidation occured.
	BlockTimeMs int64 `protobuf:"varint,15,opt,name=block_time_ms,json=blockTimeMs,proto3" json:"block_time_ms,omitempty"`
}

func (m *PositionLiquidatedEvent) Reset()         { *m = PositionLiquidatedEvent{} }
func (m *PositionLiquidatedEvent) String() string { return proto.CompactTextString(m) }
func (*PositionLiquidatedEvent) ProtoMessage()    {}
func (*PositionLiquidatedEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_a5313bbc89fa31dd, []int{1}
}
func (m *PositionLiquidatedEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PositionLiquidatedEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PositionLiquidatedEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PositionLiquidatedEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PositionLiquidatedEvent.Merge(m, src)
}
func (m *PositionLiquidatedEvent) XXX_Size() int {
	return m.Size()
}
func (m *PositionLiquidatedEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_PositionLiquidatedEvent.DiscardUnknown(m)
}

var xxx_messageInfo_PositionLiquidatedEvent proto.InternalMessageInfo

func (m *PositionLiquidatedEvent) GetTraderAddress() string {
	if m != nil {
		return m.TraderAddress
	}
	return ""
}

func (m *PositionLiquidatedEvent) GetLiquidatorAddress() string {
	if m != nil {
		return m.LiquidatorAddress
	}
	return ""
}

func (m *PositionLiquidatedEvent) GetFeeToLiquidator() types.Coin {
	if m != nil {
		return m.FeeToLiquidator
	}
	return types.Coin{}
}

func (m *PositionLiquidatedEvent) GetFeeToEcosystemFund() types.Coin {
	if m != nil {
		return m.FeeToEcosystemFund
	}
	return types.Coin{}
}

func (m *PositionLiquidatedEvent) GetBadDebt() types.Coin {
	if m != nil {
		return m.BadDebt
	}
	return types.Coin{}
}

func (m *PositionLiquidatedEvent) GetMargin() types.Coin {
	if m != nil {
		return m.Margin
	}
	return types.Coin{}
}

func (m *PositionLiquidatedEvent) GetBlockHeight() int64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *PositionLiquidatedEvent) GetBlockTimeMs() int64 {
	if m != nil {
		return m.BlockTimeMs
	}
	return 0
}

// Emitted when a position is settled.
type PositionSettledEvent struct {
	// Identifier for the virtual pool of the position.
	Pair github_com_NibiruChain_nibiru_x_common_asset.Pair `protobuf:"bytes,1,opt,name=pair,proto3,customtype=github.com/NibiruChain/nibiru/x/common/asset.Pair" json:"pair"`
	// Owner of the position.
	TraderAddress string `protobuf:"bytes,2,opt,name=trader_address,json=traderAddress,proto3" json:"trader_address,omitempty"`
	// Settled coin as dictated by the settlement price of the perp.amm.
	SettledCoins github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,3,rep,name=settled_coins,json=settledCoins,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"settled_coins" yaml:"settled_coins"`
}

func (m *PositionSettledEvent) Reset()         { *m = PositionSettledEvent{} }
func (m *PositionSettledEvent) String() string { return proto.CompactTextString(m) }
func (*PositionSettledEvent) ProtoMessage()    {}
func (*PositionSettledEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_a5313bbc89fa31dd, []int{2}
}
func (m *PositionSettledEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PositionSettledEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PositionSettledEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PositionSettledEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PositionSettledEvent.Merge(m, src)
}
func (m *PositionSettledEvent) XXX_Size() int {
	return m.Size()
}
func (m *PositionSettledEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_PositionSettledEvent.DiscardUnknown(m)
}

var xxx_messageInfo_PositionSettledEvent proto.InternalMessageInfo

func (m *PositionSettledEvent) GetTraderAddress() string {
	if m != nil {
		return m.TraderAddress
	}
	return ""
}

func (m *PositionSettledEvent) GetSettledCoins() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.SettledCoins
	}
	return nil
}

// Emitted when the funding rate changes for a market.
type FundingRateChangedEvent struct {
	// The pair for which the funding rate was calculated.
	Pair github_com_NibiruChain_nibiru_x_common_asset.Pair `protobuf:"bytes,1,opt,name=pair,proto3,customtype=github.com/NibiruChain/nibiru/x/common/asset.Pair" json:"pair"`
	// The mark price of the pair.
	MarkPriceTwap github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,2,opt,name=mark_price_twap,json=markPriceTwap,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"mark_price_twap"`
	// The oracle index price of the pair.
	IndexPriceTwap github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,3,opt,name=index_price_twap,json=indexPriceTwap,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"index_price_twap"`
	// The latest premium fraction just calculated.
	PremiumFraction github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,5,opt,name=premium_fraction,json=premiumFraction,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"premium_fraction"`
	// The market's latest cumulative premium fraction.
	// The funding payment a position will pay is the difference between this
	// value and the latest cumulative premium fraction on the position,
	// multiplied by the position size.
	CumulativePremiumFraction github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,6,opt,name=cumulative_premium_fraction,json=cumulativePremiumFraction,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"cumulative_premium_fraction"`
}

func (m *FundingRateChangedEvent) Reset()         { *m = FundingRateChangedEvent{} }
func (m *FundingRateChangedEvent) String() string { return proto.CompactTextString(m) }
func (*FundingRateChangedEvent) ProtoMessage()    {}
func (*FundingRateChangedEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_a5313bbc89fa31dd, []int{3}
}
func (m *FundingRateChangedEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FundingRateChangedEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FundingRateChangedEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FundingRateChangedEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FundingRateChangedEvent.Merge(m, src)
}
func (m *FundingRateChangedEvent) XXX_Size() int {
	return m.Size()
}
func (m *FundingRateChangedEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_FundingRateChangedEvent.DiscardUnknown(m)
}

var xxx_messageInfo_FundingRateChangedEvent proto.InternalMessageInfo

// Emitted when liquidation fails.
type LiquidationFailedEvent struct {
	// The pair for which we are trying to liquidate.
	Pair github_com_NibiruChain_nibiru_x_common_asset.Pair `protobuf:"bytes,1,opt,name=pair,proto3,customtype=github.com/NibiruChain/nibiru/x/common/asset.Pair" json:"pair"`
	// owner of the position.
	Trader string `protobuf:"bytes,2,opt,name=trader,proto3" json:"trader,omitempty"`
	// Address of the account that executed the tx.
	Liquidator string `protobuf:"bytes,3,opt,name=liquidator,proto3" json:"liquidator,omitempty"`
	// Reason for the liquidation failure.
	Reason LiquidationFailedEvent_LiquidationFailedReason `protobuf:"varint,4,opt,name=reason,proto3,enum=nibiru.perp.v2.LiquidationFailedEvent_LiquidationFailedReason" json:"reason,omitempty"`
}

func (m *LiquidationFailedEvent) Reset()         { *m = LiquidationFailedEvent{} }
func (m *LiquidationFailedEvent) String() string { return proto.CompactTextString(m) }
func (*LiquidationFailedEvent) ProtoMessage()    {}
func (*LiquidationFailedEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_a5313bbc89fa31dd, []int{4}
}
func (m *LiquidationFailedEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LiquidationFailedEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LiquidationFailedEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LiquidationFailedEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LiquidationFailedEvent.Merge(m, src)
}
func (m *LiquidationFailedEvent) XXX_Size() int {
	return m.Size()
}
func (m *LiquidationFailedEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_LiquidationFailedEvent.DiscardUnknown(m)
}

var xxx_messageInfo_LiquidationFailedEvent proto.InternalMessageInfo

func (m *LiquidationFailedEvent) GetTrader() string {
	if m != nil {
		return m.Trader
	}
	return ""
}

func (m *LiquidationFailedEvent) GetLiquidator() string {
	if m != nil {
		return m.Liquidator
	}
	return ""
}

func (m *LiquidationFailedEvent) GetReason() LiquidationFailedEvent_LiquidationFailedReason {
	if m != nil {
		return m.Reason
	}
	return LiquidationFailedEvent_UNSPECIFIED
}

// This event is emitted when the amm is updated, which can be triggered by
// the following events:
//
// - swap
// - edit price multiplier
// - edit depth
type AmmUpdatedEvent struct {
	// the final state of the AMM
	FinalAmm AMM `protobuf:"bytes,1,opt,name=final_amm,json=finalAmm,proto3" json:"final_amm"`
	// The mark price of the pair.
	MarkPriceTwap github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,2,opt,name=mark_price_twap,json=markPriceTwap,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"mark_price_twap"`
	// The oracle index price of the pair.
	IndexPriceTwap github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,3,opt,name=index_price_twap,json=indexPriceTwap,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"index_price_twap"`
}

func (m *AmmUpdatedEvent) Reset()         { *m = AmmUpdatedEvent{} }
func (m *AmmUpdatedEvent) String() string { return proto.CompactTextString(m) }
func (*AmmUpdatedEvent) ProtoMessage()    {}
func (*AmmUpdatedEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_a5313bbc89fa31dd, []int{5}
}
func (m *AmmUpdatedEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AmmUpdatedEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AmmUpdatedEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AmmUpdatedEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AmmUpdatedEvent.Merge(m, src)
}
func (m *AmmUpdatedEvent) XXX_Size() int {
	return m.Size()
}
func (m *AmmUpdatedEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_AmmUpdatedEvent.DiscardUnknown(m)
}

var xxx_messageInfo_AmmUpdatedEvent proto.InternalMessageInfo

func (m *AmmUpdatedEvent) GetFinalAmm() AMM {
	if m != nil {
		return m.FinalAmm
	}
	return AMM{}
}

// This event is emitted at the end of every block for persisting market changes
// off-chain
//
// Market changes are triggered by the following actions:
//
// - disabling market
// - changing market fees
// - bad debt is prepaid by the ecosystem fund
type MarketUpdatedEvent struct {
	// the final state of the market
	FinalMarket Market `protobuf:"bytes,1,opt,name=final_market,json=finalMarket,proto3" json:"final_market"`
}

func (m *MarketUpdatedEvent) Reset()         { *m = MarketUpdatedEvent{} }
func (m *MarketUpdatedEvent) String() string { return proto.CompactTextString(m) }
func (*MarketUpdatedEvent) ProtoMessage()    {}
func (*MarketUpdatedEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_a5313bbc89fa31dd, []int{6}
}
func (m *MarketUpdatedEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MarketUpdatedEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MarketUpdatedEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MarketUpdatedEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarketUpdatedEvent.Merge(m, src)
}
func (m *MarketUpdatedEvent) XXX_Size() int {
	return m.Size()
}
func (m *MarketUpdatedEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_MarketUpdatedEvent.DiscardUnknown(m)
}

var xxx_messageInfo_MarketUpdatedEvent proto.InternalMessageInfo

func (m *MarketUpdatedEvent) GetFinalMarket() Market {
	if m != nil {
		return m.FinalMarket
	}
	return Market{}
}

func init() {
	proto.RegisterEnum("nibiru.perp.v2.LiquidationFailedEvent_LiquidationFailedReason", LiquidationFailedEvent_LiquidationFailedReason_name, LiquidationFailedEvent_LiquidationFailedReason_value)
	proto.RegisterType((*PositionChangedEvent)(nil), "nibiru.perp.v2.PositionChangedEvent")
	proto.RegisterType((*PositionLiquidatedEvent)(nil), "nibiru.perp.v2.PositionLiquidatedEvent")
	proto.RegisterType((*PositionSettledEvent)(nil), "nibiru.perp.v2.PositionSettledEvent")
	proto.RegisterType((*FundingRateChangedEvent)(nil), "nibiru.perp.v2.FundingRateChangedEvent")
	proto.RegisterType((*LiquidationFailedEvent)(nil), "nibiru.perp.v2.LiquidationFailedEvent")
	proto.RegisterType((*AmmUpdatedEvent)(nil), "nibiru.perp.v2.AmmUpdatedEvent")
	proto.RegisterType((*MarketUpdatedEvent)(nil), "nibiru.perp.v2.MarketUpdatedEvent")
}

func init() { proto.RegisterFile("nibiru/perp/v2/event.proto", fileDescriptor_a5313bbc89fa31dd) }

var fileDescriptor_a5313bbc89fa31dd = []byte{
	// 1207 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x97, 0xcf, 0x6f, 0x1b, 0x45,
	0x14, 0xc7, 0xe3, 0xa4, 0x4d, 0x93, 0x89, 0x7f, 0x75, 0x70, 0x93, 0x6d, 0xa9, 0x9c, 0xb0, 0x02,
	0x94, 0x4b, 0x77, 0xd5, 0x20, 0x21, 0xb5, 0x07, 0x90, 0x93, 0x3a, 0xc4, 0x52, 0xe3, 0xba, 0x6b,
	0xa7, 0xb4, 0x70, 0x58, 0xcd, 0xee, 0x8e, 0x9d, 0x51, 0x3c, 0x33, 0xdb, 0x9d, 0xd9, 0xb4, 0xe9,
	0x5f, 0xc0, 0x05, 0x89, 0x1b, 0xff, 0x03, 0x7f, 0x02, 0x7f, 0x41, 0x8f, 0x3d, 0x22, 0x0e, 0x05,
	0xb5, 0xe2, 0xc0, 0x95, 0x2b, 0x17, 0xb4, 0x33, 0xb3, 0xb1, 0x9d, 0x94, 0x94, 0x58, 0x45, 0x88,
	0x93, 0xbd, 0xef, 0xcd, 0xfb, 0xbc, 0x37, 0xcf, 0xdf, 0x99, 0x7d, 0x06, 0xd7, 0x18, 0x09, 0x48,
	0x92, 0xba, 0x31, 0x4e, 0x62, 0xf7, 0x70, 0xc3, 0xc5, 0x87, 0x98, 0x49, 0x27, 0x4e, 0xb8, 0xe4,
	0xb0, 0xac, 0x7d, 0x4e, 0xe6, 0x73, 0x0e, 0x37, 0xae, 0xd5, 0x06, 0x7c, 0xc0, 0x95, 0xcb, 0xcd,
	0xbe, 0xe9, 0x55, 0xd7, 0xae, 0x0f, 0x38, 0x1f, 0x0c, 0xb1, 0x8b, 0x62, 0xe2, 0x22, 0xc6, 0xb8,
	0x44, 0x92, 0x70, 0x26, 0x8c, 0xb7, 0x1e, 0x72, 0x41, 0xb9, 0x70, 0x03, 0x24, 0xb0, 0x7b, 0x78,
	0x33, 0xc0, 0x12, 0xdd, 0x74, 0x43, 0x4e, 0x98, 0xf1, 0x9f, 0xcc, 0x2f, 0x24, 0x92, 0xd8, 0xf8,
	0x56, 0x0d, 0x59, 0x3d, 0x05, 0x69, 0xdf, 0x95, 0x84, 0x62, 0x21, 0x11, 0x8d, 0xf5, 0x02, 0xfb,
	0xc7, 0x8b, 0xa0, 0xd6, 0xe1, 0x82, 0x64, 0x09, 0xb7, 0xf6, 0x11, 0x1b, 0xe0, 0xa8, 0x99, 0xd5,
	0x0f, 0x9b, 0xa0, 0xdc, 0x27, 0x0c, 0x0d, 0xfd, 0xd8, 0x78, 0xad, 0xc2, 0x5a, 0x61, 0x7d, 0x69,
	0xc3, 0x72, 0x26, 0xb7, 0xe4, 0xe4, 0xd1, 0x9b, 0x17, 0x9e, 0xbf, 0x5c, 0x9d, 0xf1, 0x4a, 0x2a,
	0x2a, 0x37, 0xc2, 0xaf, 0xc1, 0xe5, 0x1c, 0xe0, 0x33, 0x9e, 0x7d, 0xa0, 0xa1, 0x35, 0xbb, 0x56,
	0x58, 0x5f, 0xdc, 0x74, 0xb2, 0xf5, 0x3f, 0xbf, 0x5c, 0xfd, 0x78, 0x40, 0xe4, 0x7e, 0x1a, 0x38,
	0x21, 0xa7, 0xae, 0xd9, 0xaa, 0xfe, 0xb8, 0x21, 0xa2, 0x03, 0x57, 0x1e, 0xc5, 0x58, 0x38, 0x77,
	0x70, 0xe8, 0x55, 0x73, 0x50, 0xdb, 0x70, 0x60, 0x00, 0x2a, 0x32, 0x41, 0x4c, 0xa0, 0x50, 0xf1,
	0xfb, 0x18, 0x5b, 0x73, 0xaa, 0xc8, 0xab, 0x8e, 0x26, 0x38, 0x59, 0xcf, 0x1c, 0xd3, 0x33, 0x67,
	0x8b, 0x13, 0xb6, 0x59, 0xcf, 0xb2, 0xfe, 0xf1, 0x72, 0x75, 0xf9, 0x08, 0xd1, 0xe1, 0x6d, 0xfb,
	0x44, 0xbc, 0xed, 0x95, 0xc7, 0x2c, 0xdb, 0x18, 0xc3, 0xfb, 0xa0, 0x98, 0x60, 0x34, 0x24, 0xcf,
	0x70, 0xe4, 0xc7, 0x6c, 0x68, 0x5d, 0x98, 0xaa, 0xf6, 0xa5, 0x9c, 0xd1, 0x61, 0x43, 0x78, 0x1b,
	0x2c, 0x04, 0x28, 0xf2, 0x23, 0x1c, 0x48, 0xeb, 0xe2, 0xdb, 0xea, 0xd5, 0x5d, 0xbd, 0x14, 0xa0,
	0xe8, 0x0e, 0x0e, 0x24, 0xfc, 0x12, 0x54, 0xfa, 0x29, 0x8b, 0x08, 0x1b, 0xf8, 0x31, 0x3a, 0xa2,
	0x98, 0x49, 0x6b, 0x7e, 0xaa, 0x8a, 0xca, 0x06, 0xd3, 0xd1, 0x14, 0xf8, 0x01, 0x28, 0x06, 0x43,
	0x1e, 0x1e, 0xf8, 0xfb, 0x98, 0x0c, 0xf6, 0xa5, 0x75, 0x69, 0xad, 0xb0, 0x3e, 0xe7, 0x2d, 0x29,
	0xdb, 0x8e, 0x32, 0xc1, 0x1e, 0x28, 0x53, 0x94, 0x0c, 0x08, 0xf3, 0x25, 0xf7, 0x53, 0x81, 0x13,
	0x6b, 0xe1, 0xdc, 0xa9, 0x5b, 0x4c, 0x7a, 0x45, 0x4d, 0xe9, 0xf1, 0x3d, 0x81, 0x13, 0x78, 0x0b,
	0x94, 0x42, 0x25, 0x3c, 0x3f, 0xc1, 0x48, 0x70, 0x66, 0x2d, 0x2a, 0x68, 0xcd, 0x40, 0x8b, 0x5a,
	0x95, 0x9e, 0xf2, 0x79, 0xc5, 0x70, 0xec, 0xc9, 0xfe, 0x76, 0x11, 0xac, 0xe4, 0x4a, 0xbb, 0x4b,
	0x1e, 0xa7, 0x24, 0x42, 0x32, 0xd7, 0xef, 0x2e, 0xb8, 0x10, 0x23, 0x92, 0x28, 0xd5, 0x2e, 0x6e,
	0xde, 0x32, 0xb4, 0x9b, 0x63, 0x25, 0xb6, 0x95, 0x8e, 0xb7, 0xf6, 0x11, 0x61, 0xae, 0x39, 0x42,
	0x4f, 0xdd, 0x90, 0x53, 0xca, 0x99, 0x8b, 0x84, 0xc0, 0xd2, 0xe9, 0x20, 0x92, 0x78, 0x0a, 0x03,
	0x3f, 0x02, 0x99, 0x30, 0x22, 0x9c, 0xf8, 0x28, 0x8a, 0x12, 0x2c, 0x84, 0x16, 0xb1, 0x57, 0xd2,
	0xd6, 0x86, 0x36, 0xc2, 0x08, 0x2c, 0xe3, 0xa7, 0xba, 0xc6, 0xc8, 0x7f, 0x9c, 0x72, 0x89, 0x7d,
	0x44, 0x79, 0xca, 0xa4, 0x12, 0xe6, 0xf9, 0x7f, 0xa5, 0xda, 0x31, 0xed, 0x7e, 0x06, 0x6b, 0x28,
	0x16, 0xec, 0x83, 0x95, 0x51, 0x96, 0xe3, 0xe3, 0x25, 0xc8, 0x33, 0x3c, 0xa5, 0x3c, 0xaf, 0x1c,
	0xe3, 0xf2, 0x76, 0x76, 0xc9, 0x33, 0x0c, 0x6f, 0x00, 0x38, 0x34, 0x6d, 0xe5, 0xa3, 0x8d, 0x5f,
	0x54, 0x1b, 0xbf, 0x3c, 0xf2, 0xe4, 0x9b, 0x1f, 0x80, 0xcb, 0x7d, 0x8c, 0x33, 0x71, 0x8c, 0x7c,
	0x4a, 0x9d, 0x67, 0x0a, 0x7c, 0xcd, 0x1c, 0x48, 0x4b, 0x1f, 0xc8, 0x53, 0x04, 0xdb, 0xab, 0xf4,
	0x31, 0xee, 0xf1, 0xbb, 0xc7, 0x16, 0x98, 0x80, 0x2b, 0x66, 0x19, 0x0e, 0xb9, 0x38, 0x12, 0x12,
	0x53, 0x3f, 0x93, 0xb3, 0x12, 0xed, 0x99, 0xc9, 0x3e, 0x34, 0xc9, 0xae, 0x4f, 0x24, 0x9b, 0xa4,
	0xd8, 0x1e, 0x54, 0x09, 0x9b, 0xb9, 0x75, 0x3b, 0x65, 0xd1, 0xc4, 0xa1, 0x5d, 0x38, 0xe7, 0xa1,
	0xdd, 0x01, 0xf3, 0x5a, 0xf2, 0x4a, 0xdb, 0x67, 0x46, 0x5e, 0x31, 0x05, 0x96, 0x74, 0x81, 0x3a,
	0xcc, 0xf6, 0x4c, 0xfc, 0x9b, 0xaf, 0x53, 0xf0, 0x8e, 0xae, 0xd3, 0x2e, 0x28, 0x4d, 0x8a, 0x69,
	0x69, 0x2a, 0x70, 0x31, 0x1e, 0xd7, 0x50, 0x0f, 0x94, 0x52, 0x36, 0x76, 0xfb, 0x59, 0xc5, 0xa9,
	0xa0, 0x93, 0x10, 0xb8, 0x0b, 0x00, 0x45, 0xc9, 0x81, 0x1f, 0x27, 0x24, 0xc4, 0x56, 0x69, 0x2a,
	0xe4, 0x62, 0x46, 0xe8, 0x64, 0x80, 0x53, 0x97, 0x5f, 0xf9, 0xf4, 0xe5, 0x67, 0x83, 0x92, 0x5e,
	0x92, 0xbd, 0x41, 0x7d, 0x2a, 0xac, 0xca, 0xd8, 0x9a, 0x1e, 0xa1, 0x78, 0x57, 0xd8, 0xdf, 0xcf,
	0x8e, 0x5e, 0xa6, 0x5d, 0x2c, 0xe5, 0xf0, 0xbf, 0xbd, 0x8c, 0xbe, 0x29, 0x80, 0x92, 0xd0, 0x65,
	0xf8, 0xd9, 0xbc, 0x20, 0xac, 0xb9, 0xb5, 0xb9, 0xb3, 0xe5, 0xb7, 0x63, 0xe4, 0x57, 0xd3, 0xf2,
	0x9b, 0x88, 0xb6, 0x7f, 0xf8, 0x65, 0x75, 0xfd, 0x1f, 0xf4, 0x36, 0x03, 0x09, 0xaf, 0x68, 0x62,
	0xd5, 0x93, 0xfd, 0xdb, 0x1c, 0x58, 0xd9, 0xd6, 0x2f, 0x1c, 0x0f, 0x49, 0x3c, 0x31, 0x69, 0xbc,
	0xe3, 0xe6, 0x3c, 0x00, 0x95, 0x91, 0x34, 0x7c, 0xf9, 0x04, 0xc5, 0x53, 0xce, 0x1b, 0xa5, 0x63,
	0x7d, 0xf4, 0x9e, 0xa0, 0x18, 0x3e, 0x04, 0x55, 0xc2, 0x22, 0xfc, 0x74, 0x1c, 0x3c, 0xdd, 0xa5,
	0x5e, 0x56, 0x9c, 0x11, 0xf9, 0x11, 0xa8, 0xc6, 0x09, 0xa6, 0x24, 0xa5, 0x7e, 0x3f, 0xd1, 0x93,
	0x87, 0xbe, 0x64, 0xcf, 0x4d, 0xae, 0x18, 0xce, 0xb6, 0xc1, 0x40, 0x06, 0xde, 0x0f, 0x53, 0x9a,
	0x0e, 0x91, 0x24, 0x87, 0xd8, 0x3f, 0x95, 0x65, 0xba, 0xd1, 0xe1, 0xea, 0x08, 0xd9, 0x99, 0xcc,
	0x67, 0xff, 0x3e, 0x0b, 0x96, 0xf3, 0x8b, 0x3a, 0x1b, 0xa0, 0x10, 0xf9, 0xb7, 0xce, 0xc0, 0x32,
	0x98, 0xd7, 0x6a, 0x37, 0xda, 0x37, 0x4f, 0xb0, 0x0e, 0xc0, 0xd8, 0xdb, 0x47, 0xfd, 0x40, 0xde,
	0x98, 0x05, 0x3e, 0x00, 0xf3, 0x66, 0xce, 0xc8, 0x5e, 0x95, 0xe5, 0x8d, 0xcf, 0x4e, 0xce, 0xb3,
	0x6f, 0x2e, 0xff, 0xb4, 0xd9, 0x4c, 0x24, 0x86, 0x66, 0xc7, 0x60, 0xe5, 0x6f, 0x96, 0xc0, 0x0a,
	0x58, 0xda, 0x6b, 0x77, 0x3b, 0xcd, 0xad, 0xd6, 0x76, 0xab, 0x79, 0xa7, 0x3a, 0x03, 0x6b, 0xa0,
	0xda, 0xb9, 0xd7, 0x6d, 0xf5, 0x5a, 0xf7, 0xda, 0xfe, 0x4e, 0xb3, 0x71, 0xb7, 0xb7, 0xf3, 0xa8,
	0x5a, 0xc8, 0xac, 0xed, 0x7b, 0xed, 0xe6, 0xc3, 0x56, 0xb7, 0xd7, 0x6c, 0xf7, 0xfc, 0x4e, 0xa3,
	0xe5, 0x55, 0x67, 0xa1, 0x05, 0x6a, 0x13, 0x56, 0x13, 0x57, 0x9d, 0xb3, 0xff, 0x2c, 0x80, 0x4a,
	0x83, 0xd2, 0xbd, 0x78, 0x6c, 0xea, 0xf9, 0x14, 0x2c, 0xea, 0xa9, 0x1d, 0x51, 0x6a, 0x06, 0xf6,
	0xf7, 0x4e, 0x6e, 0xb0, 0xb1, 0xbb, 0x6b, 0x5e, 0x50, 0x0b, 0x6a, 0x6d, 0x83, 0xd2, 0xff, 0xdf,
	0xa1, 0xb1, 0xf7, 0x00, 0xdc, 0x45, 0xc9, 0x01, 0x96, 0x13, 0xfb, 0xff, 0x1c, 0x14, 0xf5, 0xfe,
	0xa9, 0xf2, 0x99, 0x16, 0x2c, 0x9f, 0x6c, 0x81, 0x8e, 0x34, 0x5d, 0x58, 0x52, 0x11, 0xc6, 0xf4,
	0xc5, 0xf3, 0x57, 0xf5, 0xc2, 0x8b, 0x57, 0xf5, 0xc2, 0xaf, 0xaf, 0xea, 0x85, 0xef, 0x5e, 0xd7,
	0x67, 0x5e, 0xbc, 0xae, 0xcf, 0xfc, 0xf4, 0xba, 0x3e, 0xf3, 0xd5, 0x8d, 0xb7, 0x29, 0x35, 0xff,
	0xff, 0xa5, 0x6a, 0x0e, 0xe6, 0xd5, 0xff, 0xab, 0x4f, 0xfe, 0x0a, 0x00, 0x00, 0xff, 0xff, 0x47,
	0x6e, 0xc2, 0x7f, 0x1e, 0x0e, 0x00, 0x00,
}

func (m *PositionChangedEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PositionChangedEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PositionChangedEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.ChangeReason.Size()
		i -= size
		if _, err := m.ChangeReason.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	{
		size := m.MarginToUser.Size()
		i -= size
		if _, err := m.MarginToUser.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	if m.BlockHeight != 0 {
		i = encodeVarintEvent(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x38
	}
	{
		size := m.FundingPayment.Size()
		i -= size
		if _, err := m.FundingPayment.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size, err := m.BadDebt.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.RealizedPnl.Size()
		i -= size
		if _, err := m.RealizedPnl.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.TransactionFee.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.PositionNotional.Size()
		i -= size
		if _, err := m.PositionNotional.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.FinalPosition.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *PositionLiquidatedEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PositionLiquidatedEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PositionLiquidatedEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BlockTimeMs != 0 {
		i = encodeVarintEvent(dAtA, i, uint64(m.BlockTimeMs))
		i--
		dAtA[i] = 0x78
	}
	if m.BlockHeight != 0 {
		i = encodeVarintEvent(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x70
	}
	{
		size := m.MarkPrice.Size()
		i -= size
		if _, err := m.MarkPrice.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x6a
	{
		size := m.UnrealizedPnl.Size()
		i -= size
		if _, err := m.UnrealizedPnl.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	{
		size := m.PositionSize.Size()
		i -= size
		if _, err := m.PositionSize.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x5a
	{
		size := m.PositionNotional.Size()
		i -= size
		if _, err := m.PositionNotional.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	{
		size, err := m.Margin.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	{
		size, err := m.BadDebt.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size, err := m.FeeToEcosystemFund.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size, err := m.FeeToLiquidator.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if len(m.LiquidatorAddress) > 0 {
		i -= len(m.LiquidatorAddress)
		copy(dAtA[i:], m.LiquidatorAddress)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.LiquidatorAddress)))
		i--
		dAtA[i] = 0x2a
	}
	{
		size := m.ExchangedPositionSize.Size()
		i -= size
		if _, err := m.ExchangedPositionSize.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.ExchangedQuoteAmount.Size()
		i -= size
		if _, err := m.ExchangedQuoteAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.TraderAddress) > 0 {
		i -= len(m.TraderAddress)
		copy(dAtA[i:], m.TraderAddress)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.TraderAddress)))
		i--
		dAtA[i] = 0x12
	}
	{
		size := m.Pair.Size()
		i -= size
		if _, err := m.Pair.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *PositionSettledEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PositionSettledEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PositionSettledEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SettledCoins) > 0 {
		for iNdEx := len(m.SettledCoins) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SettledCoins[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvent(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.TraderAddress) > 0 {
		i -= len(m.TraderAddress)
		copy(dAtA[i:], m.TraderAddress)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.TraderAddress)))
		i--
		dAtA[i] = 0x12
	}
	{
		size := m.Pair.Size()
		i -= size
		if _, err := m.Pair.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *FundingRateChangedEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FundingRateChangedEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FundingRateChangedEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.CumulativePremiumFraction.Size()
		i -= size
		if _, err := m.CumulativePremiumFraction.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.PremiumFraction.Size()
		i -= size
		if _, err := m.PremiumFraction.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.IndexPriceTwap.Size()
		i -= size
		if _, err := m.IndexPriceTwap.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.MarkPriceTwap.Size()
		i -= size
		if _, err := m.MarkPriceTwap.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.Pair.Size()
		i -= size
		if _, err := m.Pair.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *LiquidationFailedEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LiquidationFailedEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LiquidationFailedEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Reason != 0 {
		i = encodeVarintEvent(dAtA, i, uint64(m.Reason))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Liquidator) > 0 {
		i -= len(m.Liquidator)
		copy(dAtA[i:], m.Liquidator)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Liquidator)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Trader) > 0 {
		i -= len(m.Trader)
		copy(dAtA[i:], m.Trader)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Trader)))
		i--
		dAtA[i] = 0x12
	}
	{
		size := m.Pair.Size()
		i -= size
		if _, err := m.Pair.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AmmUpdatedEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AmmUpdatedEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AmmUpdatedEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.IndexPriceTwap.Size()
		i -= size
		if _, err := m.IndexPriceTwap.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.MarkPriceTwap.Size()
		i -= size
		if _, err := m.MarkPriceTwap.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.FinalAmm.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MarketUpdatedEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarketUpdatedEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MarketUpdatedEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.FinalMarket.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintEvent(dAtA []byte, offset int, v uint64) int {
	offset -= sovEvent(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *PositionChangedEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.FinalPosition.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = m.PositionNotional.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = m.TransactionFee.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = m.RealizedPnl.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = m.BadDebt.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = m.FundingPayment.Size()
	n += 1 + l + sovEvent(uint64(l))
	if m.BlockHeight != 0 {
		n += 1 + sovEvent(uint64(m.BlockHeight))
	}
	l = m.MarginToUser.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = m.ChangeReason.Size()
	n += 1 + l + sovEvent(uint64(l))
	return n
}

func (m *PositionLiquidatedEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Pair.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = len(m.TraderAddress)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = m.ExchangedQuoteAmount.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = m.ExchangedPositionSize.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = len(m.LiquidatorAddress)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = m.FeeToLiquidator.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = m.FeeToEcosystemFund.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = m.BadDebt.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = m.Margin.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = m.PositionNotional.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = m.PositionSize.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = m.UnrealizedPnl.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = m.MarkPrice.Size()
	n += 1 + l + sovEvent(uint64(l))
	if m.BlockHeight != 0 {
		n += 1 + sovEvent(uint64(m.BlockHeight))
	}
	if m.BlockTimeMs != 0 {
		n += 1 + sovEvent(uint64(m.BlockTimeMs))
	}
	return n
}

func (m *PositionSettledEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Pair.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = len(m.TraderAddress)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	if len(m.SettledCoins) > 0 {
		for _, e := range m.SettledCoins {
			l = e.Size()
			n += 1 + l + sovEvent(uint64(l))
		}
	}
	return n
}

func (m *FundingRateChangedEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Pair.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = m.MarkPriceTwap.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = m.IndexPriceTwap.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = m.PremiumFraction.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = m.CumulativePremiumFraction.Size()
	n += 1 + l + sovEvent(uint64(l))
	return n
}

func (m *LiquidationFailedEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Pair.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = len(m.Trader)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Liquidator)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	if m.Reason != 0 {
		n += 1 + sovEvent(uint64(m.Reason))
	}
	return n
}

func (m *AmmUpdatedEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.FinalAmm.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = m.MarkPriceTwap.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = m.IndexPriceTwap.Size()
	n += 1 + l + sovEvent(uint64(l))
	return n
}

func (m *MarketUpdatedEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.FinalMarket.Size()
	n += 1 + l + sovEvent(uint64(l))
	return n
}

func sovEvent(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozEvent(x uint64) (n int) {
	return sovEvent(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *PositionChangedEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PositionChangedEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PositionChangedEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinalPosition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FinalPosition.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionNotional", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PositionNotional.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionFee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TransactionFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RealizedPnl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RealizedPnl.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadDebt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BadDebt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FundingPayment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FundingPayment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarginToUser", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MarginToUser.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ChangeReason.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PositionLiquidatedEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PositionLiquidatedEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PositionLiquidatedEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pair", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Pair.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraderAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TraderAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExchangedQuoteAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ExchangedQuoteAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExchangedPositionSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ExchangedPositionSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiquidatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LiquidatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeToLiquidator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FeeToLiquidator.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeToEcosystemFund", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FeeToEcosystemFund.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadDebt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BadDebt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Margin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Margin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionNotional", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PositionNotional.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PositionSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnrealizedPnl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.UnrealizedPnl.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarkPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MarkPrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockTimeMs", wireType)
			}
			m.BlockTimeMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockTimeMs |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PositionSettledEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PositionSettledEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PositionSettledEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pair", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Pair.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraderAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TraderAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettledCoins", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SettledCoins = append(m.SettledCoins, types.Coin{})
			if err := m.SettledCoins[len(m.SettledCoins)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FundingRateChangedEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FundingRateChangedEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FundingRateChangedEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pair", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Pair.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarkPriceTwap", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MarkPriceTwap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexPriceTwap", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.IndexPriceTwap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PremiumFraction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PremiumFraction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CumulativePremiumFraction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CumulativePremiumFraction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LiquidationFailedEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LiquidationFailedEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LiquidationFailedEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pair", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Pair.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Trader = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Liquidator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Liquidator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			m.Reason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reason |= LiquidationFailedEvent_LiquidationFailedReason(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AmmUpdatedEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AmmUpdatedEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AmmUpdatedEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinalAmm", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FinalAmm.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarkPriceTwap", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MarkPriceTwap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexPriceTwap", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.IndexPriceTwap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarketUpdatedEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarketUpdatedEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarketUpdatedEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinalMarket", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FinalMarket.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEvent(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthEvent
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupEvent
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthEvent
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthEvent        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEvent          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupEvent = fmt.Errorf("proto: unexpected end of group")
)
