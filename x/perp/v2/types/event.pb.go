// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: nibiru/perp/v2/event.proto

package types

import (
	fmt "fmt"
	github_com_NibiruChain_nibiru_x_common_asset "github.com/NibiruChain/nibiru/x/common/asset"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type LiquidationFailedEvent_LiquidationFailedReason int32

const (
	LiquidationFailedEvent_UNSPECIFIED LiquidationFailedEvent_LiquidationFailedReason = 0
	// the position is healthy and does not need to be liquidated.
	LiquidationFailedEvent_POSITION_HEALTHY LiquidationFailedEvent_LiquidationFailedReason = 1
	// the pair does not exist.
	LiquidationFailedEvent_NONEXISTENT_PAIR LiquidationFailedEvent_LiquidationFailedReason = 2
	// the position does not exist.
	LiquidationFailedEvent_NONEXISTENT_POSITION LiquidationFailedEvent_LiquidationFailedReason = 3
)

var LiquidationFailedEvent_LiquidationFailedReason_name = map[int32]string{
	0: "UNSPECIFIED",
	1: "POSITION_HEALTHY",
	2: "NONEXISTENT_PAIR",
	3: "NONEXISTENT_POSITION",
}

var LiquidationFailedEvent_LiquidationFailedReason_value = map[string]int32{
	"UNSPECIFIED":          0,
	"POSITION_HEALTHY":     1,
	"NONEXISTENT_PAIR":     2,
	"NONEXISTENT_POSITION": 3,
}

func (x LiquidationFailedEvent_LiquidationFailedReason) String() string {
	return proto.EnumName(LiquidationFailedEvent_LiquidationFailedReason_name, int32(x))
}

func (LiquidationFailedEvent_LiquidationFailedReason) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a5313bbc89fa31dd, []int{4, 0}
}

// Emitted when a position changes.
type PositionChangedEvent struct {
	FinalPosition Position `protobuf:"bytes,1,opt,name=final_position,json=finalPosition,proto3" json:"final_position"`
	// Position notional (in quote units) after the change. In general,
	// 'notional = baseAmount * priceQuotePerBase', where size is the baseAmount.
	PositionNotional github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,2,opt,name=position_notional,json=positionNotional,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"position_notional"`
	// Transaction fee paid. A "taker" fee.
	TransactionFee types.Coin `protobuf:"bytes,3,opt,name=transaction_fee,json=transactionFee,proto3" json:"transaction_fee" yaml:"transaction_fee"`
	// realize profits and losses after the change
	RealizedPnl github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,4,opt,name=realized_pnl,json=realizedPnl,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"realized_pnl"`
	// Amount of bad debt cleared by the PerpEF during the change.
	// Bad debt is negative net margin past the liquidation point of a position.
	BadDebt types.Coin `protobuf:"bytes,5,opt,name=bad_debt,json=badDebt,proto3" json:"bad_debt"`
	// A funding payment made or received by the trader on the current position.
	//'fundingPayment' is positive if 'owner' is the sender and negative if 'owner'
	//is the receiver of the payment. Its magnitude is abs(size * fundingRate).
	//Funding payments act to converge the mark price and index price
	//(average price on major exchanges).
	FundingPayment github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,6,opt,name=funding_payment,json=fundingPayment,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"funding_payment"`
	// The block number at which this position was changed.
	BlockHeight int64 `protobuf:"varint,7,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
	// margin_to_user is the amount of collateral received by the trader during
	// the position change. A positve value indicates that the trader received
	// funds, while a negative value indicates that the trader spent funds.
	MarginToUser github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,8,opt,name=margin_to_user,json=marginToUser,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"margin_to_user"`
	// change_reason describes the reason for why the position resulted in a
	// change. Change type can take the following values:
	//
	// - CHANGE_REASON_UNSPECIFIED: Unspecified change reason.
	// - CHANGE_REASON_ADD_MARGIN: Margin was added to the position.
	// - CHANGE_REASON_REMOVE_MARGIN: Margin was removed from the position.
	// - CHANGE_REASON_OPEN_POSITION: A new position was opened.
	// - CHANGE_REASON_CLOSE_POSITION: An existing position was closed.
	ChangeReason ChangeReason `protobuf:"bytes,9,opt,name=change_reason,json=changeReason,proto3,customtype=ChangeReason" json:"change_reason"`
	// exchanged_size represent the change in size for an existing position
	// after the change. A positive value indicates that the position size
	// increased, while a negative value indicates that the position size
	// decreased.
	ExchangedSize github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,10,opt,name=exchanged_size,json=exchangedSize,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"exchanged_size"`
	// exchanged_notional represent the change in notional for an existing
	// position after the change. A positive value indicates that the position
	// notional increased, while a negative value indicates that the position
	// notional decreased.
	ExchangedNotional github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,11,opt,name=exchanged_notional,json=exchangedNotional,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"exchanged_notional"`
}

func (m *PositionChangedEvent) Reset()         { *m = PositionChangedEvent{} }
func (m *PositionChangedEvent) String() string { return proto.CompactTextString(m) }
func (*PositionChangedEvent) ProtoMessage()    {}
func (*PositionChangedEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_a5313bbc89fa31dd, []int{0}
}
func (m *PositionChangedEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PositionChangedEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PositionChangedEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PositionChangedEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PositionChangedEvent.Merge(m, src)
}
func (m *PositionChangedEvent) XXX_Size() int {
	return m.Size()
}
func (m *PositionChangedEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_PositionChangedEvent.DiscardUnknown(m)
}

var xxx_messageInfo_PositionChangedEvent proto.InternalMessageInfo

func (m *PositionChangedEvent) GetFinalPosition() Position {
	if m != nil {
		return m.FinalPosition
	}
	return Position{}
}

func (m *PositionChangedEvent) GetTransactionFee() types.Coin {
	if m != nil {
		return m.TransactionFee
	}
	return types.Coin{}
}

func (m *PositionChangedEvent) GetBadDebt() types.Coin {
	if m != nil {
		return m.BadDebt
	}
	return types.Coin{}
}

func (m *PositionChangedEvent) GetBlockHeight() int64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

// Emitted when a position is liquidated. Wraps a PositionChanged event since a
// liquidation causes position changes.
type PositionLiquidatedEvent struct {
	PositionChangedEvent PositionChangedEvent `protobuf:"bytes,1,opt,name=position_changed_event,json=positionChangedEvent,proto3" json:"position_changed_event"`
	// Address of the account that executed the tx.
	LiquidatorAddress string `protobuf:"bytes,2,opt,name=liquidator_address,json=liquidatorAddress,proto3" json:"liquidator_address,omitempty"`
	// Commission (in margin units) received by 'liquidator'.
	FeeToLiquidator types.Coin `protobuf:"bytes,3,opt,name=fee_to_liquidator,json=feeToLiquidator,proto3" json:"fee_to_liquidator" yaml:"fee_to_liquidator"`
	// Commission (in margin units) given to the ecosystem fund.
	FeeToEcosystemFund types.Coin `protobuf:"bytes,4,opt,name=fee_to_ecosystem_fund,json=feeToEcosystemFund,proto3" json:"fee_to_ecosystem_fund" yaml:"fee_to_ecosystem_fund"`
}

func (m *PositionLiquidatedEvent) Reset()         { *m = PositionLiquidatedEvent{} }
func (m *PositionLiquidatedEvent) String() string { return proto.CompactTextString(m) }
func (*PositionLiquidatedEvent) ProtoMessage()    {}
func (*PositionLiquidatedEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_a5313bbc89fa31dd, []int{1}
}
func (m *PositionLiquidatedEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PositionLiquidatedEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PositionLiquidatedEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PositionLiquidatedEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PositionLiquidatedEvent.Merge(m, src)
}
func (m *PositionLiquidatedEvent) XXX_Size() int {
	return m.Size()
}
func (m *PositionLiquidatedEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_PositionLiquidatedEvent.DiscardUnknown(m)
}

var xxx_messageInfo_PositionLiquidatedEvent proto.InternalMessageInfo

func (m *PositionLiquidatedEvent) GetPositionChangedEvent() PositionChangedEvent {
	if m != nil {
		return m.PositionChangedEvent
	}
	return PositionChangedEvent{}
}

func (m *PositionLiquidatedEvent) GetLiquidatorAddress() string {
	if m != nil {
		return m.LiquidatorAddress
	}
	return ""
}

func (m *PositionLiquidatedEvent) GetFeeToLiquidator() types.Coin {
	if m != nil {
		return m.FeeToLiquidator
	}
	return types.Coin{}
}

func (m *PositionLiquidatedEvent) GetFeeToEcosystemFund() types.Coin {
	if m != nil {
		return m.FeeToEcosystemFund
	}
	return types.Coin{}
}

// Emitted when a position is settled.
type PositionSettledEvent struct {
	// Identifier for the virtual pool of the position.
	Pair github_com_NibiruChain_nibiru_x_common_asset.Pair `protobuf:"bytes,1,opt,name=pair,proto3,customtype=github.com/NibiruChain/nibiru/x/common/asset.Pair" json:"pair"`
	// Owner of the position.
	TraderAddress string `protobuf:"bytes,2,opt,name=trader_address,json=traderAddress,proto3" json:"trader_address,omitempty"`
	// Settled coin as dictated by the settlement price of the perp.amm.
	SettledCoins github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,3,rep,name=settled_coins,json=settledCoins,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"settled_coins" yaml:"settled_coins"`
}

func (m *PositionSettledEvent) Reset()         { *m = PositionSettledEvent{} }
func (m *PositionSettledEvent) String() string { return proto.CompactTextString(m) }
func (*PositionSettledEvent) ProtoMessage()    {}
func (*PositionSettledEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_a5313bbc89fa31dd, []int{2}
}
func (m *PositionSettledEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PositionSettledEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PositionSettledEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PositionSettledEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PositionSettledEvent.Merge(m, src)
}
func (m *PositionSettledEvent) XXX_Size() int {
	return m.Size()
}
func (m *PositionSettledEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_PositionSettledEvent.DiscardUnknown(m)
}

var xxx_messageInfo_PositionSettledEvent proto.InternalMessageInfo

func (m *PositionSettledEvent) GetTraderAddress() string {
	if m != nil {
		return m.TraderAddress
	}
	return ""
}

func (m *PositionSettledEvent) GetSettledCoins() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.SettledCoins
	}
	return nil
}

// Emitted when the funding rate changes for a market.
type FundingRateChangedEvent struct {
	// The pair for which the funding rate was calculated.
	Pair github_com_NibiruChain_nibiru_x_common_asset.Pair `protobuf:"bytes,1,opt,name=pair,proto3,customtype=github.com/NibiruChain/nibiru/x/common/asset.Pair" json:"pair"`
	// The mark price of the pair.
	MarkPriceTwap github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,2,opt,name=mark_price_twap,json=markPriceTwap,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"mark_price_twap"`
	// The oracle index price of the pair.
	IndexPriceTwap github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,3,opt,name=index_price_twap,json=indexPriceTwap,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"index_price_twap"`
	// The latest premium fraction just calculated.
	PremiumFraction github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,5,opt,name=premium_fraction,json=premiumFraction,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"premium_fraction"`
	// The market's latest cumulative premium fraction.
	// The funding payment a position will pay is the difference between this
	// value and the latest cumulative premium fraction on the position,
	// multiplied by the position size.
	CumulativePremiumFraction github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,6,opt,name=cumulative_premium_fraction,json=cumulativePremiumFraction,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"cumulative_premium_fraction"`
}

func (m *FundingRateChangedEvent) Reset()         { *m = FundingRateChangedEvent{} }
func (m *FundingRateChangedEvent) String() string { return proto.CompactTextString(m) }
func (*FundingRateChangedEvent) ProtoMessage()    {}
func (*FundingRateChangedEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_a5313bbc89fa31dd, []int{3}
}
func (m *FundingRateChangedEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FundingRateChangedEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FundingRateChangedEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FundingRateChangedEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FundingRateChangedEvent.Merge(m, src)
}
func (m *FundingRateChangedEvent) XXX_Size() int {
	return m.Size()
}
func (m *FundingRateChangedEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_FundingRateChangedEvent.DiscardUnknown(m)
}

var xxx_messageInfo_FundingRateChangedEvent proto.InternalMessageInfo

// Emitted when liquidation fails.
type LiquidationFailedEvent struct {
	// The pair for which we are trying to liquidate.
	Pair github_com_NibiruChain_nibiru_x_common_asset.Pair `protobuf:"bytes,1,opt,name=pair,proto3,customtype=github.com/NibiruChain/nibiru/x/common/asset.Pair" json:"pair"`
	// owner of the position.
	Trader string `protobuf:"bytes,2,opt,name=trader,proto3" json:"trader,omitempty"`
	// Address of the account that executed the tx.
	Liquidator string `protobuf:"bytes,3,opt,name=liquidator,proto3" json:"liquidator,omitempty"`
	// Reason for the liquidation failure.
	Reason LiquidationFailedEvent_LiquidationFailedReason `protobuf:"varint,4,opt,name=reason,proto3,enum=nibiru.perp.v2.LiquidationFailedEvent_LiquidationFailedReason" json:"reason,omitempty"`
}

func (m *LiquidationFailedEvent) Reset()         { *m = LiquidationFailedEvent{} }
func (m *LiquidationFailedEvent) String() string { return proto.CompactTextString(m) }
func (*LiquidationFailedEvent) ProtoMessage()    {}
func (*LiquidationFailedEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_a5313bbc89fa31dd, []int{4}
}
func (m *LiquidationFailedEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LiquidationFailedEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LiquidationFailedEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LiquidationFailedEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LiquidationFailedEvent.Merge(m, src)
}
func (m *LiquidationFailedEvent) XXX_Size() int {
	return m.Size()
}
func (m *LiquidationFailedEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_LiquidationFailedEvent.DiscardUnknown(m)
}

var xxx_messageInfo_LiquidationFailedEvent proto.InternalMessageInfo

func (m *LiquidationFailedEvent) GetTrader() string {
	if m != nil {
		return m.Trader
	}
	return ""
}

func (m *LiquidationFailedEvent) GetLiquidator() string {
	if m != nil {
		return m.Liquidator
	}
	return ""
}

func (m *LiquidationFailedEvent) GetReason() LiquidationFailedEvent_LiquidationFailedReason {
	if m != nil {
		return m.Reason
	}
	return LiquidationFailedEvent_UNSPECIFIED
}

// This event is emitted when the amm is updated, which can be triggered by
// the following events:
//
// - swap
// - edit price multiplier
// - edit depth
type AmmUpdatedEvent struct {
	// the final state of the AMM
	FinalAmm AMM `protobuf:"bytes,1,opt,name=final_amm,json=finalAmm,proto3" json:"final_amm"`
	// The mark price of the pair.
	MarkPriceTwap github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,2,opt,name=mark_price_twap,json=markPriceTwap,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"mark_price_twap"`
	// The oracle index price of the pair.
	IndexPriceTwap github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,3,opt,name=index_price_twap,json=indexPriceTwap,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"index_price_twap"`
}

func (m *AmmUpdatedEvent) Reset()         { *m = AmmUpdatedEvent{} }
func (m *AmmUpdatedEvent) String() string { return proto.CompactTextString(m) }
func (*AmmUpdatedEvent) ProtoMessage()    {}
func (*AmmUpdatedEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_a5313bbc89fa31dd, []int{5}
}
func (m *AmmUpdatedEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AmmUpdatedEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AmmUpdatedEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AmmUpdatedEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AmmUpdatedEvent.Merge(m, src)
}
func (m *AmmUpdatedEvent) XXX_Size() int {
	return m.Size()
}
func (m *AmmUpdatedEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_AmmUpdatedEvent.DiscardUnknown(m)
}

var xxx_messageInfo_AmmUpdatedEvent proto.InternalMessageInfo

func (m *AmmUpdatedEvent) GetFinalAmm() AMM {
	if m != nil {
		return m.FinalAmm
	}
	return AMM{}
}

// This event is emitted at the end of every block for persisting market changes
// off-chain
//
// Market changes are triggered by the following actions:
//
// - disabling market
// - changing market fees
// - bad debt is prepaid by the ecosystem fund
type MarketUpdatedEvent struct {
	// the final state of the market
	FinalMarket Market `protobuf:"bytes,1,opt,name=final_market,json=finalMarket,proto3" json:"final_market"`
}

func (m *MarketUpdatedEvent) Reset()         { *m = MarketUpdatedEvent{} }
func (m *MarketUpdatedEvent) String() string { return proto.CompactTextString(m) }
func (*MarketUpdatedEvent) ProtoMessage()    {}
func (*MarketUpdatedEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_a5313bbc89fa31dd, []int{6}
}
func (m *MarketUpdatedEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MarketUpdatedEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MarketUpdatedEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MarketUpdatedEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarketUpdatedEvent.Merge(m, src)
}
func (m *MarketUpdatedEvent) XXX_Size() int {
	return m.Size()
}
func (m *MarketUpdatedEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_MarketUpdatedEvent.DiscardUnknown(m)
}

var xxx_messageInfo_MarketUpdatedEvent proto.InternalMessageInfo

func (m *MarketUpdatedEvent) GetFinalMarket() Market {
	if m != nil {
		return m.FinalMarket
	}
	return Market{}
}

func init() {
	proto.RegisterEnum("nibiru.perp.v2.LiquidationFailedEvent_LiquidationFailedReason", LiquidationFailedEvent_LiquidationFailedReason_name, LiquidationFailedEvent_LiquidationFailedReason_value)
	proto.RegisterType((*PositionChangedEvent)(nil), "nibiru.perp.v2.PositionChangedEvent")
	proto.RegisterType((*PositionLiquidatedEvent)(nil), "nibiru.perp.v2.PositionLiquidatedEvent")
	proto.RegisterType((*PositionSettledEvent)(nil), "nibiru.perp.v2.PositionSettledEvent")
	proto.RegisterType((*FundingRateChangedEvent)(nil), "nibiru.perp.v2.FundingRateChangedEvent")
	proto.RegisterType((*LiquidationFailedEvent)(nil), "nibiru.perp.v2.LiquidationFailedEvent")
	proto.RegisterType((*AmmUpdatedEvent)(nil), "nibiru.perp.v2.AmmUpdatedEvent")
	proto.RegisterType((*MarketUpdatedEvent)(nil), "nibiru.perp.v2.MarketUpdatedEvent")
}

func init() { proto.RegisterFile("nibiru/perp/v2/event.proto", fileDescriptor_a5313bbc89fa31dd) }

var fileDescriptor_a5313bbc89fa31dd = []byte{
	// 1109 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x96, 0x4f, 0x6f, 0x1b, 0x45,
	0x14, 0xc0, 0xe3, 0xb8, 0xa4, 0xcd, 0xf8, 0x6f, 0x06, 0x93, 0x6e, 0x43, 0xe5, 0x84, 0x55, 0x41,
	0xb9, 0x64, 0x57, 0x09, 0x12, 0x52, 0x7b, 0x00, 0x39, 0x89, 0x43, 0x2c, 0x25, 0x8e, 0xd9, 0x38,
	0xa5, 0x05, 0xa1, 0x65, 0x76, 0x77, 0xec, 0x8c, 0xe2, 0x9d, 0x59, 0x76, 0xc6, 0x69, 0x92, 0x2f,
	0x00, 0x47, 0x6e, 0x7c, 0x07, 0x3e, 0x49, 0x8f, 0x3d, 0x22, 0x0e, 0x01, 0x25, 0xe2, 0xc0, 0x0d,
	0x71, 0xe5, 0x82, 0x76, 0x66, 0x36, 0xfe, 0x93, 0xb6, 0xa1, 0x16, 0x1c, 0x38, 0xd9, 0xfb, 0xde,
	0xbc, 0xdf, 0xfb, 0xb3, 0xef, 0xbd, 0x59, 0xb0, 0x40, 0x89, 0x47, 0xe2, 0xbe, 0x1d, 0xe1, 0x38,
	0xb2, 0x8f, 0xd7, 0x6c, 0x7c, 0x8c, 0xa9, 0xb0, 0xa2, 0x98, 0x09, 0x06, 0x8b, 0x4a, 0x67, 0x25,
	0x3a, 0xeb, 0x78, 0x6d, 0xa1, 0xd2, 0x65, 0x5d, 0x26, 0x55, 0x76, 0xf2, 0x4f, 0x9d, 0x5a, 0xb8,
	0xdf, 0x65, 0xac, 0xdb, 0xc3, 0x36, 0x8a, 0x88, 0x8d, 0x28, 0x65, 0x02, 0x09, 0xc2, 0x28, 0xd7,
	0xda, 0xaa, 0xcf, 0x78, 0xc8, 0xb8, 0xed, 0x21, 0x8e, 0xed, 0xe3, 0x55, 0x0f, 0x0b, 0xb4, 0x6a,
	0xfb, 0x8c, 0x50, 0xad, 0x1f, 0xf7, 0xcf, 0x05, 0x12, 0x58, 0xeb, 0x16, 0x35, 0x59, 0x3e, 0x79,
	0xfd, 0x8e, 0x2d, 0x48, 0x88, 0xb9, 0x40, 0x61, 0xa4, 0x0e, 0x98, 0x7f, 0xcc, 0x80, 0x4a, 0x8b,
	0x71, 0x92, 0x38, 0xdc, 0x38, 0x44, 0xb4, 0x8b, 0x83, 0x7a, 0x12, 0x3f, 0xac, 0x83, 0x62, 0x87,
	0x50, 0xd4, 0x73, 0x23, 0xad, 0x35, 0x32, 0x4b, 0x99, 0xe5, 0xdc, 0x9a, 0x61, 0x8d, 0xa6, 0x64,
	0xa5, 0xd6, 0xeb, 0xb7, 0x9e, 0x9f, 0x2f, 0x4e, 0x39, 0x05, 0x69, 0x95, 0x0a, 0xe1, 0x97, 0x60,
	0x2e, 0x05, 0xb8, 0x94, 0x25, 0x3f, 0xa8, 0x67, 0x4c, 0x2f, 0x65, 0x96, 0x67, 0xd7, 0xad, 0xe4,
	0xfc, 0xcf, 0xe7, 0x8b, 0x1f, 0x74, 0x89, 0x38, 0xec, 0x7b, 0x96, 0xcf, 0x42, 0x5b, 0xa7, 0xaa,
	0x7e, 0x56, 0x78, 0x70, 0x64, 0x8b, 0xd3, 0x08, 0x73, 0x6b, 0x13, 0xfb, 0x4e, 0x39, 0x05, 0x35,
	0x35, 0x07, 0x7a, 0xa0, 0x24, 0x62, 0x44, 0x39, 0xf2, 0x25, 0xbf, 0x83, 0xb1, 0x91, 0x95, 0x41,
	0xde, 0xb3, 0x14, 0xc1, 0x4a, 0x6a, 0x66, 0xe9, 0x9a, 0x59, 0x1b, 0x8c, 0xd0, 0xf5, 0x6a, 0xe2,
	0xf5, 0xcf, 0xf3, 0xc5, 0xf9, 0x53, 0x14, 0xf6, 0x1e, 0x99, 0x63, 0xf6, 0xa6, 0x53, 0x1c, 0x92,
	0x6c, 0x61, 0x0c, 0x3f, 0x03, 0xf9, 0x18, 0xa3, 0x1e, 0x39, 0xc3, 0x81, 0x1b, 0xd1, 0x9e, 0x71,
	0x6b, 0xa2, 0xd8, 0x73, 0x29, 0xa3, 0x45, 0x7b, 0xf0, 0x11, 0xb8, 0xe3, 0xa1, 0xc0, 0x0d, 0xb0,
	0x27, 0x8c, 0xb7, 0x6e, 0x8a, 0x57, 0x55, 0xf5, 0xb6, 0x87, 0x82, 0x4d, 0xec, 0x09, 0xf8, 0x39,
	0x28, 0x75, 0xfa, 0x34, 0x20, 0xb4, 0xeb, 0x46, 0xe8, 0x34, 0xc4, 0x54, 0x18, 0x33, 0x13, 0x45,
	0x54, 0xd4, 0x98, 0x96, 0xa2, 0xc0, 0xf7, 0x40, 0xde, 0xeb, 0x31, 0xff, 0xc8, 0x3d, 0xc4, 0xa4,
	0x7b, 0x28, 0x8c, 0xdb, 0x4b, 0x99, 0xe5, 0xac, 0x93, 0x93, 0xb2, 0x6d, 0x29, 0x82, 0x6d, 0x50,
	0x0c, 0x51, 0xdc, 0x25, 0xd4, 0x15, 0xcc, 0xed, 0x73, 0x1c, 0x1b, 0x77, 0xde, 0xd8, 0x75, 0x83,
	0x0a, 0x27, 0xaf, 0x28, 0x6d, 0x76, 0xc0, 0x71, 0x0c, 0x1f, 0x82, 0x82, 0x2f, 0x1b, 0xcf, 0x8d,
	0x31, 0xe2, 0x8c, 0x1a, 0xb3, 0x12, 0x5a, 0xd1, 0xd0, 0xbc, 0xea, 0x4a, 0x47, 0xea, 0x9c, 0xbc,
	0x3f, 0xf4, 0x04, 0x0f, 0x40, 0x11, 0x9f, 0x28, 0x49, 0xe0, 0x72, 0x72, 0x86, 0x0d, 0x30, 0x51,
	0x2d, 0x0a, 0x57, 0x94, 0x7d, 0x72, 0x86, 0xe1, 0x57, 0x00, 0x0e, 0xb0, 0x57, 0x4d, 0x9b, 0x9b,
	0x08, 0x3d, 0x77, 0x45, 0x4a, 0xbb, 0xd6, 0xfc, 0x36, 0x0b, 0xee, 0xa6, 0xf3, 0xb1, 0x43, 0xbe,
	0xe9, 0x93, 0x00, 0x89, 0x74, 0xea, 0xbe, 0x06, 0xf3, 0x57, 0xe3, 0x92, 0x46, 0x20, 0xf7, 0x89,
	0x9e, 0xbe, 0x07, 0xaf, 0x9a, 0xbe, 0xe1, 0xd9, 0xd5, 0x3d, 0x53, 0x89, 0x5e, 0x36, 0xd7, 0x2b,
	0x00, 0xf6, 0xb4, 0x53, 0x16, 0xbb, 0x28, 0x08, 0x62, 0xcc, 0xb9, 0x9a, 0x48, 0x67, 0x6e, 0xa0,
	0xa9, 0x29, 0x05, 0xec, 0x82, 0xb9, 0x0e, 0xc6, 0xc9, 0x0b, 0x1f, 0xe8, 0x6e, 0x1e, 0xb2, 0x25,
	0x3d, 0x64, 0x86, 0x1a, 0xb2, 0x6b, 0x04, 0xd3, 0x29, 0x75, 0x30, 0x6e, 0xb3, 0x9d, 0x2b, 0x09,
	0x8c, 0xc1, 0x3b, 0xfa, 0x18, 0xf6, 0x19, 0x3f, 0xe5, 0x02, 0x87, 0x6e, 0xd2, 0xa2, 0x72, 0xe0,
	0x5e, 0xeb, 0xec, 0x81, 0x76, 0x76, 0x7f, 0xc4, 0xd9, 0x28, 0xc5, 0x74, 0xa0, 0x74, 0x58, 0x4f,
	0xa5, 0x5b, 0x89, 0xf0, 0x87, 0xe9, 0xc1, 0xf2, 0xdb, 0xc7, 0x42, 0xf4, 0xd2, 0x22, 0xed, 0x82,
	0x5b, 0x11, 0x22, 0xb1, 0x2c, 0xfa, 0xec, 0xfa, 0x43, 0xfd, 0xce, 0x57, 0x87, 0xde, 0x79, 0x53,
	0xbe, 0x86, 0x8d, 0x43, 0x44, 0xa8, 0xad, 0xf7, 0xef, 0x89, 0xed, 0xb3, 0x30, 0x64, 0xd4, 0x46,
	0x9c, 0x63, 0x61, 0xb5, 0x10, 0x89, 0x1d, 0x89, 0x81, 0xef, 0x83, 0x64, 0xab, 0x04, 0x78, 0xbc,
	0xde, 0x05, 0x25, 0x4d, 0x6b, 0xfd, 0x5d, 0x06, 0x14, 0xb8, 0x0a, 0xc3, 0x4d, 0xf6, 0x3b, 0x37,
	0xb2, 0x4b, 0xd9, 0xd7, 0xe7, 0xbe, 0xad, 0x73, 0xaf, 0xa8, 0xdc, 0x47, 0xac, 0xcd, 0x1f, 0x7f,
	0x59, 0x5c, 0xfe, 0x07, 0x6d, 0x9a, 0x80, 0xb8, 0x93, 0xd7, 0xb6, 0xf2, 0xc9, 0xfc, 0x2d, 0x0b,
	0xee, 0x6e, 0xa9, 0x05, 0xe1, 0x20, 0x81, 0x47, 0x3a, 0xe8, 0x5f, 0x2e, 0xce, 0x63, 0x50, 0x0a,
	0x51, 0x7c, 0xe4, 0x46, 0x31, 0xf1, 0xb1, 0x2b, 0x9e, 0xa1, 0x68, 0xc2, 0xfb, 0xa1, 0x90, 0x60,
	0x5a, 0x09, 0xa5, 0xfd, 0x0c, 0x45, 0xf0, 0x09, 0x28, 0x13, 0x1a, 0xe0, 0x93, 0x61, 0x70, 0x76,
	0xb2, 0x55, 0x29, 0x39, 0x03, 0xf2, 0x53, 0x50, 0x8e, 0x62, 0x1c, 0x92, 0x7e, 0xe8, 0x76, 0x62,
	0x75, 0x53, 0xc8, 0x3d, 0xfe, 0xe6, 0xe4, 0x92, 0xe6, 0x6c, 0x69, 0x0c, 0xa4, 0xe0, 0x5d, 0xbf,
	0x1f, 0xf6, 0x7b, 0x48, 0x90, 0x63, 0xec, 0x5e, 0xf3, 0x32, 0xd9, 0xaa, 0xbf, 0x37, 0x40, 0xb6,
	0x46, 0xfd, 0x99, 0xbf, 0x4f, 0x83, 0xf9, 0x74, 0x08, 0x93, 0x0b, 0x0f, 0x91, 0xff, 0x6a, 0x06,
	0xe6, 0xc1, 0x8c, 0xea, 0x76, 0xdd, 0xfb, 0xfa, 0x09, 0x56, 0x01, 0x18, 0xdb, 0x2c, 0xb3, 0xce,
	0x90, 0x04, 0x3e, 0x06, 0x33, 0xfa, 0x5e, 0x48, 0x16, 0x41, 0x71, 0xed, 0xe3, 0xf1, 0x0d, 0xf8,
	0xf2, 0xf0, 0xaf, 0x8b, 0xf5, 0x0d, 0xa2, 0x69, 0x66, 0x04, 0xee, 0xbe, 0xe2, 0x08, 0x2c, 0x81,
	0xdc, 0x41, 0x73, 0xbf, 0x55, 0xdf, 0x68, 0x6c, 0x35, 0xea, 0x9b, 0xe5, 0x29, 0x58, 0x01, 0xe5,
	0xd6, 0xde, 0x7e, 0xa3, 0xdd, 0xd8, 0x6b, 0xba, 0xdb, 0xf5, 0xda, 0x4e, 0x7b, 0xfb, 0x69, 0x39,
	0x93, 0x48, 0x9b, 0x7b, 0xcd, 0xfa, 0x93, 0xc6, 0x7e, 0xbb, 0xde, 0x6c, 0xbb, 0xad, 0x5a, 0xc3,
	0x29, 0x4f, 0x43, 0x03, 0x54, 0x46, 0xa4, 0xda, 0xae, 0x9c, 0x35, 0xff, 0xca, 0x80, 0x52, 0x2d,
	0x0c, 0x0f, 0xa2, 0xa1, 0x7d, 0xff, 0x11, 0x98, 0x55, 0x5f, 0x59, 0x28, 0x0c, 0xf5, 0x8a, 0x7f,
	0x7b, 0x3c, 0xc1, 0xda, 0xee, 0xae, 0xde, 0xe8, 0x77, 0xe4, 0xd9, 0x5a, 0x18, 0xfe, 0xff, 0x86,
	0xc6, 0x3c, 0x00, 0x70, 0x17, 0xc5, 0x47, 0x58, 0x8c, 0xe4, 0xff, 0x09, 0xc8, 0xab, 0xfc, 0x43,
	0xa9, 0xd3, 0x25, 0x98, 0x1f, 0x2f, 0x81, 0xb2, 0xd4, 0x55, 0xc8, 0x49, 0x0b, 0x2d, 0xfa, 0xf4,
	0xf9, 0x45, 0x35, 0xf3, 0xe2, 0xa2, 0x9a, 0xf9, 0xf5, 0xa2, 0x9a, 0xf9, 0xfe, 0xb2, 0x3a, 0xf5,
	0xe2, 0xb2, 0x3a, 0xf5, 0xd3, 0x65, 0x75, 0xea, 0x8b, 0x95, 0x9b, 0x3a, 0x35, 0xfd, 0x5e, 0x96,
	0x31, 0x7b, 0x33, 0xf2, 0x7b, 0xf8, 0xc3, 0xbf, 0x03, 0x00, 0x00, 0xff, 0xff, 0xc9, 0xe7, 0x3a,
	0x1d, 0xce, 0x0b, 0x00, 0x00,
}

func (m *PositionChangedEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PositionChangedEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PositionChangedEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.ExchangedNotional.Size()
		i -= size
		if _, err := m.ExchangedNotional.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x5a
	{
		size := m.ExchangedSize.Size()
		i -= size
		if _, err := m.ExchangedSize.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	{
		size := m.ChangeReason.Size()
		i -= size
		if _, err := m.ChangeReason.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	{
		size := m.MarginToUser.Size()
		i -= size
		if _, err := m.MarginToUser.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	if m.BlockHeight != 0 {
		i = encodeVarintEvent(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x38
	}
	{
		size := m.FundingPayment.Size()
		i -= size
		if _, err := m.FundingPayment.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size, err := m.BadDebt.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.RealizedPnl.Size()
		i -= size
		if _, err := m.RealizedPnl.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.TransactionFee.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.PositionNotional.Size()
		i -= size
		if _, err := m.PositionNotional.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.FinalPosition.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *PositionLiquidatedEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PositionLiquidatedEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PositionLiquidatedEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.FeeToEcosystemFund.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.FeeToLiquidator.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.LiquidatorAddress) > 0 {
		i -= len(m.LiquidatorAddress)
		copy(dAtA[i:], m.LiquidatorAddress)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.LiquidatorAddress)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.PositionChangedEvent.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *PositionSettledEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PositionSettledEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PositionSettledEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SettledCoins) > 0 {
		for iNdEx := len(m.SettledCoins) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SettledCoins[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvent(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.TraderAddress) > 0 {
		i -= len(m.TraderAddress)
		copy(dAtA[i:], m.TraderAddress)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.TraderAddress)))
		i--
		dAtA[i] = 0x12
	}
	{
		size := m.Pair.Size()
		i -= size
		if _, err := m.Pair.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *FundingRateChangedEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FundingRateChangedEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FundingRateChangedEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.CumulativePremiumFraction.Size()
		i -= size
		if _, err := m.CumulativePremiumFraction.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.PremiumFraction.Size()
		i -= size
		if _, err := m.PremiumFraction.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.IndexPriceTwap.Size()
		i -= size
		if _, err := m.IndexPriceTwap.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.MarkPriceTwap.Size()
		i -= size
		if _, err := m.MarkPriceTwap.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.Pair.Size()
		i -= size
		if _, err := m.Pair.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *LiquidationFailedEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LiquidationFailedEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LiquidationFailedEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Reason != 0 {
		i = encodeVarintEvent(dAtA, i, uint64(m.Reason))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Liquidator) > 0 {
		i -= len(m.Liquidator)
		copy(dAtA[i:], m.Liquidator)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Liquidator)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Trader) > 0 {
		i -= len(m.Trader)
		copy(dAtA[i:], m.Trader)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Trader)))
		i--
		dAtA[i] = 0x12
	}
	{
		size := m.Pair.Size()
		i -= size
		if _, err := m.Pair.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AmmUpdatedEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AmmUpdatedEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AmmUpdatedEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.IndexPriceTwap.Size()
		i -= size
		if _, err := m.IndexPriceTwap.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.MarkPriceTwap.Size()
		i -= size
		if _, err := m.MarkPriceTwap.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.FinalAmm.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MarketUpdatedEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarketUpdatedEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MarketUpdatedEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.FinalMarket.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintEvent(dAtA []byte, offset int, v uint64) int {
	offset -= sovEvent(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *PositionChangedEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.FinalPosition.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = m.PositionNotional.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = m.TransactionFee.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = m.RealizedPnl.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = m.BadDebt.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = m.FundingPayment.Size()
	n += 1 + l + sovEvent(uint64(l))
	if m.BlockHeight != 0 {
		n += 1 + sovEvent(uint64(m.BlockHeight))
	}
	l = m.MarginToUser.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = m.ChangeReason.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = m.ExchangedSize.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = m.ExchangedNotional.Size()
	n += 1 + l + sovEvent(uint64(l))
	return n
}

func (m *PositionLiquidatedEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.PositionChangedEvent.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = len(m.LiquidatorAddress)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = m.FeeToLiquidator.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = m.FeeToEcosystemFund.Size()
	n += 1 + l + sovEvent(uint64(l))
	return n
}

func (m *PositionSettledEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Pair.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = len(m.TraderAddress)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	if len(m.SettledCoins) > 0 {
		for _, e := range m.SettledCoins {
			l = e.Size()
			n += 1 + l + sovEvent(uint64(l))
		}
	}
	return n
}

func (m *FundingRateChangedEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Pair.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = m.MarkPriceTwap.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = m.IndexPriceTwap.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = m.PremiumFraction.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = m.CumulativePremiumFraction.Size()
	n += 1 + l + sovEvent(uint64(l))
	return n
}

func (m *LiquidationFailedEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Pair.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = len(m.Trader)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Liquidator)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	if m.Reason != 0 {
		n += 1 + sovEvent(uint64(m.Reason))
	}
	return n
}

func (m *AmmUpdatedEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.FinalAmm.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = m.MarkPriceTwap.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = m.IndexPriceTwap.Size()
	n += 1 + l + sovEvent(uint64(l))
	return n
}

func (m *MarketUpdatedEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.FinalMarket.Size()
	n += 1 + l + sovEvent(uint64(l))
	return n
}

func sovEvent(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozEvent(x uint64) (n int) {
	return sovEvent(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *PositionChangedEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PositionChangedEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PositionChangedEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinalPosition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FinalPosition.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionNotional", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PositionNotional.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionFee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TransactionFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RealizedPnl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RealizedPnl.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadDebt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BadDebt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FundingPayment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FundingPayment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarginToUser", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MarginToUser.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ChangeReason.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExchangedSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ExchangedSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExchangedNotional", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ExchangedNotional.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PositionLiquidatedEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PositionLiquidatedEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PositionLiquidatedEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionChangedEvent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PositionChangedEvent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiquidatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LiquidatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeToLiquidator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FeeToLiquidator.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeToEcosystemFund", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FeeToEcosystemFund.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PositionSettledEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PositionSettledEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PositionSettledEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pair", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Pair.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraderAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TraderAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettledCoins", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SettledCoins = append(m.SettledCoins, types.Coin{})
			if err := m.SettledCoins[len(m.SettledCoins)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FundingRateChangedEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FundingRateChangedEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FundingRateChangedEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pair", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Pair.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarkPriceTwap", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MarkPriceTwap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexPriceTwap", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.IndexPriceTwap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PremiumFraction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PremiumFraction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CumulativePremiumFraction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CumulativePremiumFraction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LiquidationFailedEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LiquidationFailedEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LiquidationFailedEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pair", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Pair.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Trader = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Liquidator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Liquidator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			m.Reason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reason |= LiquidationFailedEvent_LiquidationFailedReason(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AmmUpdatedEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AmmUpdatedEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AmmUpdatedEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinalAmm", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FinalAmm.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarkPriceTwap", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MarkPriceTwap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexPriceTwap", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.IndexPriceTwap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarketUpdatedEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarketUpdatedEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarketUpdatedEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinalMarket", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FinalMarket.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEvent(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthEvent
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupEvent
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthEvent
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthEvent        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEvent          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupEvent = fmt.Errorf("proto: unexpected end of group")
)
